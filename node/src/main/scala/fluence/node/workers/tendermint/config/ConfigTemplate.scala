/*
 * Copyright 2018 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fluence.node.workers.tendermint.config
import java.nio.file.StandardCopyOption.REPLACE_EXISTING
import java.nio.file.{Files, Path}

import cats.{Applicative, Monad}
import cats.effect.{IO, LiftIO}
import cats.syntax.flatMap._
import cats.syntax.functor._
import fluence.log.Log
import fluence.node.config.Configuration
import fluence.worker.eth.EthApp

import scala.language.higherKinds

/**
 * Provides Tendermint's configuration management, using the given path for templating
 *
 * @param defaultTendermintDir Path to directory containing default Tendermint configs generated by `tendermint init`
 * @param tendermintConfig Representation of Tendermint config.toml
 */
class ConfigTemplate private (defaultTendermintDir: Path, tendermintConfig: TendermintConfig) {

  /**
   * <pre>
   * Generates, copies and/or update different configs used by tendermint.
   * `tendermintDir` contain:
   *    - configs generated by `tendermint --init` (see [[Configuration.tendermintInit]])
   *
   * At the end of execution `dataPath` will contain:
   *    - tendermint configuration in config:
   *        - node_key.json, containing private P2P key
   *        - priv_validator_key.json, containing validator's private & public keys and it's address
   *        - genesis.json, config of the Tendermint blockchain, generated from [[EthApp.cluster]] and [[EthApp.id]]
   *        - config.toml, main Tendermint config, copied from `srcPath/config.toml` and updated
   * </pre>
   *
   * @param app App description, used to generate config.toml and genesis.conf
   * @param appTendermintDir Directory to hold app-specific Tendermint configs & data
   */
  def writeConfigs[F[_]: LiftIO: Monad: Log](
    app: EthApp,
    appTendermintDir: Path,
    p2pPort: Short,
    abciHost: String
  ): F[Unit] =
    for {
      defaultConfigs ← IO(defaultTendermintDir.resolve("config")).to[F]
      appConfigs ← IO(appTendermintDir.resolve("config")).to[F]

      defaultData ← IO(defaultTendermintDir.resolve("data")).to[F]
      appData ← IO(appTendermintDir.resolve("data")).to[F]

      _ ← IO(Files.createDirectories(appConfigs)).to[F]
      _ ← IO(Files.createDirectories(appData)).to[F]

      _ ← copyMasterKeys(defaultConfigs, appConfigs)
      _ ← copyValidatorState(defaultData, appData)
      _ ← updateConfigTOML(defaultConfigs, appConfigs, app, p2pPort, abciHost)
      _ ← GenesisConfig(app).writeTo(appConfigs)
    } yield ()

  /**
   * Takes master keys from templates dir, and copies them to destination
   *
   * @param defaultConfigs Directory containing default Tendermint configs
   * @param appConfigs Directory with app-specific Tendermint configs
   */
  private def copyMasterKeys[F[_]: Monad: LiftIO: Log](defaultConfigs: Path, appConfigs: Path): F[Unit] = {

    val nodeKey = "node_key.json"
    val validator = "priv_validator_key.json"

    Log[F].info(s"Copying node key to worker: ${defaultConfigs.resolve(nodeKey)} -> ${appConfigs.resolve(nodeKey)}") >>
      IO(Files.copy(defaultConfigs.resolve(nodeKey), appConfigs.resolve(nodeKey), REPLACE_EXISTING)).to[F] >>
      Log[F].info(
        s"Copying validator key to worker: ${defaultConfigs.resolve(validator)} -> ${appConfigs.resolve(validator)}"
      ) >>
      IO(Files.copy(defaultConfigs.resolve(validator), appConfigs.resolve(validator), REPLACE_EXISTING)).to[F].void
  }

  /**
   * Takes `config.toml` from srcPath as a template, and writes it to destPath, making necessary substitutions
   *
   * @param defaultConfigs Directory containing default Tendermint configs
   * @param appConfigs Directory with app-specific Tendermint configs
   * @param app Application to prepare
   * @param abciHost Usually Worker's name
   */
  private def updateConfigTOML[F[_]: Monad: LiftIO: Log](
    defaultConfigs: Path,
    appConfigs: Path,
    app: EthApp,
    p2pPort: Short,
    abciHost: String
  ): F[Unit] =
    for {
      configSrc <- IO(defaultConfigs.resolve("config.toml")).to[F]
      configDest <- IO(appConfigs.resolve("config.toml")).to[F]

      _ <- Log[F].info(s"Updating $configSrc -> $configDest")

      currentWorker = app.cluster.currentWorker

      _ <- tendermintConfig
        .generate[IO](
          configSrc,
          configDest,
          currentWorker.address(p2pPort),
          currentWorker.index,
          abciHost,
          app.id
        )
        .to[F]
    } yield ()

  /**
   * Copies `priv_validator_state.json` from `defaultData` to `appData`, without overwriting existing files.
   *
   * @param defaultData Directory with Tendermint's default data generated by `tendermint init`
   * @param appData Directory containing Tendermint's data for an app
   */
  private def copyValidatorState[F[_]: Monad: LiftIO: Log](defaultData: Path, appData: Path): F[Unit] = {
    val fname = "priv_validator_state.json"
    val appValidatorStateIO = IO(appData.resolve(fname))

    def copyDefaultState(): F[Unit] =
      for {
        appValidatorState <- appValidatorStateIO.to[F]
        defaultState <- IO(defaultData.resolve(fname)).to[F]
        _ <- Log[F].info(s"Copying empty validator state: $defaultState -> $appValidatorState")
        _ <- IO(Files.copy(defaultState, appValidatorState)).to[F]
      } yield ()

    for {
      stateNonEmpty <- appValidatorStateIO.map(_.toFile.exists()).to[F]
      _ <- if (stateNonEmpty) Applicative[F].unit else copyDefaultState()
    } yield ()
  }
}

object ConfigTemplate {

  /**
   *
   * Prepares the ConfigTemplate, looking for templates in `rootPath/tendermint/config`
   * Doesn't check the source templates anyhow!
   * TODO we could move `tendermint init` logic there
   *
   * @param rootPath `rootPath` is usually /master inside Master container
   */
  def apply[F[_]: LiftIO](rootPath: Path, tendermintConfig: TendermintConfig): F[ConfigTemplate] =
    IO(new ConfigTemplate(rootPath.resolve("tendermint"), tendermintConfig)).to[F]
}
