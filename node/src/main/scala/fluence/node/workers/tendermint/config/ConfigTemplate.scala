/*
 * Copyright 2018 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fluence.node.workers.tendermint.config
import java.nio.file.StandardCopyOption.REPLACE_EXISTING
import java.nio.file.{Files, Path, StandardCopyOption}

import cats.Functor
import cats.effect.{IO, LiftIO}
import fluence.node.config.Configuration
import fluence.node.eth.state.App
import slogging.LazyLogging

import scala.language.higherKinds

/**
 * Provides Tendermint's configuration management, using the given path for templating
 *
 * @param srcPath Tendermint's config path to take configs from
 */
class ConfigTemplate(srcPath: Path, tendermintConfig: TendermintConfig) extends LazyLogging {

  /**
   * Generate, copy and/or update different configs used by tendermint.
   *
   * `rootPath` is usually /master inside Master container
   * `templateConfigDir` contain:
   *    - configs generated by `tendermint --init` (see [[Configuration.tendermintInit]])
   *
   * At the end of execution `dataPath` will contain:
   *    - tendermint configuration in config:
   *        - node_key.json, containing private P2P key
   *        - priv_validator.json, containing validator's private & public keys and it's address
   *        - genesis.json, config of the Tendermint blockchain, generated from [[App.cluster]] and [[App.id]]
   *        - config.toml, main Tendermint config, copied from `srcPath/config.toml` and updated
   */
  def writeConfigs[F[_]: LiftIO: Functor](app: App, dataPath: Path, abciHost: String): F[Unit] =
    (
      for {
        configPath ← IO(dataPath.resolve("config"))
        _ ← IO(Files.createDirectories(configPath))
        _ ← copyMasterKeys(configPath)
        _ ← updateConfigTOML(configPath, app, abciHost)
        _ ← GenesisConfig(app).writeTo(configPath)
      } yield ()
    ).to[F]

  /**
   * Takes master keys from templates dir, and copies them to destination
   *
   * @param destPath Target Tendermint's config dir
   */
  def copyMasterKeys(destPath: Path): IO[Unit] = {

    val nodeKey = "node_key.json"
    val validator = "priv_validator.json"

    IO {
      logger.info(s"Copying keys to worker: ${srcPath.resolve(nodeKey)} -> ${destPath.resolve(nodeKey)}")
      Files.copy(srcPath.resolve(nodeKey), destPath.resolve(nodeKey), REPLACE_EXISTING)

      logger.info(s"Copying priv_validator to worker: ${srcPath.resolve(validator)} -> ${destPath.resolve(validator)}")
      Files.copy(srcPath.resolve(validator), destPath.resolve(validator), REPLACE_EXISTING)
    }
  }

  /**
   * Takes `config.toml` from srcPath as a template, and writes it to destPath, making necessary substitutions
   *
   * @param destPath Target Tendermint's config dir
   * @param app Application to prepare
   * @param abciHost Usually Worker's name
   */
  def updateConfigTOML(destPath: Path, app: App, abciHost: String): IO[Unit] =
    for {
      configSrc <- IO(srcPath.resolve("config.toml"))
      configDest <- IO(destPath.resolve("config.toml"))

      _ <- IO(logger.info("Updating {} -> {}", configSrc, configDest))

      currentWorker = app.cluster.currentWorker
      persistentPeers = app.cluster.workers.map(_.peerAddress)

      _ <- tendermintConfig
        .generate[IO](
          configSrc,
          configDest,
          currentWorker.address,
          currentWorker.index,
          abciHost,
          persistentPeers,
          app.id
        )
    } yield ()
}

object ConfigTemplate {

  /**
   * Prepares the ConfigTemplate, looking for templates in `rootPath/tendermint/config`
   * Doesn't check the source templates anyhow!
   * TODO we could move `tendermint init` logic there
   *
   * @param rootPath Root path
   */
  def apply[F[_]: LiftIO](rootPath: Path, tendermintConfig: TendermintConfig): F[ConfigTemplate] =
    IO(new ConfigTemplate(rootPath.resolve("tendermint").resolve("config"), tendermintConfig)).to[F]
}
