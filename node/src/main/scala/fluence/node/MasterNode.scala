/*
 * Copyright 2018 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fluence.node
import java.nio.file._

import cats.effect.{ConcurrentEffect, ExitCode, IO}
import fluence.node.config.NodeConfig
import fluence.node.eth.FluenceContract
import fluence.node.tendermint.json.{Genesis, NodeInfo}
import fluence.node.workers.{CodeManager, WorkerImage, WorkerParams, WorkersPool}
import fluence.node.tendermint.ClusterData

import scala.io.Source

/**
 * Represents a MasterNode process. Takes cluster forming events from Ethereum, and spawns new Workers to serve them.
 *
 * @param nodeConfig Tendermint/Fluence master node config
 * @param contract Contract to interact with
 * @param pool Workers pool to launch workers in
 * @param rootPath MasterNode's working directory, usually /master
 * @param ce Concurrent effect, used to subscribe to Ethereum events
 */
case class MasterNode(
  nodeConfig: NodeConfig,
  contract: FluenceContract,
  pool: WorkersPool[IO],
  codeManager: CodeManager[IO],
  rootPath: Path,
  masterNodeContainerId: Option[String]
)(implicit ce: ConcurrentEffect[IO])
    extends slogging.LazyLogging {

  /**
   * Generate, copy and/or update different configs used by tendermint and download vm code.
   *
   * `rootPath` is usually /master inside Master container
   * `templateConfigDir` contain:
   *    - configs generated by `tendermint --init` (see [[Configuration.tendermintInit]])
   *    - config/default_config.toml, copied on container build (see node's dockerfile in build.sbt)
   *
   * At the end of execution `workerPath` will contain:
   *    - vm code at `codePath`
   *    - tendermint configuration in `workerConfigDir`:
   *        - node_key.json
   *        - priv_validator.json
   *        - node_info.json, generated from [[ClusterData.nodeInfo]]
   *        - genesis.json, generated from [[ClusterData.nodeInfo.cluster.genesis]]
   *        - config.toml, copied from `templateConfigDir/default_config.toml` and updated
   */
  private val prepareWorkerParams: fs2.Pipe[IO, ClusterData, WorkerParams] =
    _.evalMap {
      case cd @ ClusterData(nodeInfo, _, code) =>
        for {
          _ ← IO { logger.info("joining cluster '{}' as node {}", cd.clusterName, cd.nodeIndex) }

          tmDir ← IO(rootPath.resolve("tendermint"))
          templateConfigDir ← IO(tmDir.resolve("config"))
          workerPath ← IO(tmDir.resolve(nodeInfo.nodeName))
          workerConfigDir ← IO(workerPath.resolve("config"))

          _ ← IO { Files.createDirectories(workerConfigDir) }

          _ ← copyMasterKeys(templateConfigDir, workerConfigDir)
          _ ← writeNodeInfo(nodeInfo, workerConfigDir)
          _ ← writeGenesis(nodeInfo.cluster.genesis, workerConfigDir)
          _ ← updateConfigTOML(
            nodeInfo,
            configSrc = templateConfigDir.resolve("default_config.toml"),
            configDest = workerConfigDir.resolve("config.toml")
          )

          codePath ← codeManager.prepareCode(code, workerPath)
        } yield WorkerParams(cd, workerPath.toString, codePath, masterNodeContainerId, nodeConfig.workerImage)
    }

  private def writeNodeInfo(nodeInfo: NodeInfo, dest: Path) = IO {
    import io.circe.syntax._

    logger.info("Writing {}/node_info.json", dest)
    Files.write(dest.resolve("node_info.json"), nodeInfo.asJson.spaces2.getBytes)
  }

  private def writeGenesis(genesis: Genesis, dest: Path) = IO {
    import io.circe.syntax._

    logger.info("Writing {}/genesis.json", dest)
    Files.write(dest.resolve("genesis.json"), genesis.asJson.spaces2.getBytes)
  }

  private def updateConfigTOML(nodeInfo: NodeInfo, configSrc: Path, configDest: Path) = IO {
    import scala.collection.JavaConverters._
    logger.info("Updating {} -> {}", configSrc, configDest)

    val persistentPeers = nodeInfo.cluster.persistent_peers
    val externalAddress = nodeInfo.cluster.external_addrs(nodeInfo.node_index.toInt)

    val lines = Source.fromFile(configSrc.toUri).getLines().map {
      case s if s.contains("external_address") => s"""external_address = "$externalAddress""""
      case s if s.contains("persistent_peers") => s"""persistent_peers = "$persistentPeers""""
      case s if s.contains("moniker") => s"""moniker = "${nodeInfo.nodeName}""""
      case s => s
    }

    Files.write(configDest, lines.toIterable.asJava)
  }

  private def copyMasterKeys(from: Path, to: Path): IO[Path] = {
    import StandardCopyOption.REPLACE_EXISTING

    val nodeKey = "node_key.json"
    val validator = "priv_validator.json"

    IO {
      logger.info(s"Copying keys to worker: ${from.resolve(nodeKey)} -> ${to.resolve(nodeKey)}")
      Files.copy(from.resolve(nodeKey), to.resolve(nodeKey), REPLACE_EXISTING)

      logger.info(s"Copying priv_validator to worker: ${from.resolve(validator)} -> ${to.resolve(validator)}")
      Files.copy(from.resolve(validator), to.resolve(validator), REPLACE_EXISTING)
    }
  }

  /**
   * Runs MasterNode. Returns when contract.getAllNodeClusters is exhausted
   * TODO: add a way to cleanup, e.g. unsubscribe and stop
   */
  val run: IO[ExitCode] =
    contract
      .getAllNodeApps(nodeConfig)
      .through(prepareWorkerParams)
      .evalTap[IO] { params ⇒
        logger.info("Running worker `{}`", params)

        pool.run(params).map(newlyAdded ⇒ logger.info(s"worker run (newly=$newlyAdded) {}", params))
      }
      .drain // drop the results, so that demand on events is always provided
      .onFinalize(IO(logger.info("subscription finalized")))
      .compile // Compile to a runnable, in terms of effect IO
      .drain // Switch to IO[Unit]
      .map(_ ⇒ ExitCode.Success)
}
