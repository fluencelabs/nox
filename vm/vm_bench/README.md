## VM benchmark tests

This benchmark consists of a few tests which can be used to measure performance of various WebAssembly virtual machines. Each test exports the `main` function which is called by the benchmark runner. There are also few compile-time parameters in each test that can be adjusted using the corresponding environment variables. Benchmark has been successfully tested on Mac and should also run smoothly on Linux.

Below we assume that Fluence GitHub repo has been already cloned and we are in the `vm_bench/tests` directory:

```shell
git clone --recursive https://github.com/fluencelabs/fluence
cd fluence/vm/vm_bench/tests
```

### Compression

This test compresses a sequence of `SEQUENCE_SIZE` bytes randomly generated by [IsaacRng](https://doc.rust-lang.org/1.0.0/rand/isaac/struct.IsaacRng.html) and has `ITERATIONS_COUNT` iterations of compressions. On each iteration a new sequence is generated by the seed that was computed based on the previous sequence. As the first seed the `SEED` parameter is used. Two compression algorithms (deflate and snappy) are supported and can be chosen by specifying the `deflate_compression` flag.

To run:

```shell
cd recursive_hash
SEED=<seed> ITERATIONS_COUNT=<iterations_count> SEQUENCE_SIZE=<sequence_size> cargo +nightly build --release --target wasm32-unknown-unknown [--feature "deflate_compression"]
```

### Factorization

This test factorizes provided `FACTORIZED_NUMBER` using [reikna](https://docs.rs/reikna/0.10.0/reikna/) library.

To run:

```shell
cd factorization_reikna
FACTORIZED_NUMBER=<number_to_factorize> cargo build --release --target wasm32-unknown-unknown
```

### Recursive fibonacci computing

This test recursively computes the Fibonacci number with the index `FIB_NUMBER`.

To run:

```shell
cd fibonacci_bigint
FIB_NUMBER=<fibonacci_number> cargo build --release --target wasm32-unknown-unknown
```

### Matrix product

This test computes a product of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations; on each iteration new matrices are generated using the seed that was computed using the previous product result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_product
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Matrix QR decomposition

This test computes a QR decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_qr_decomposition
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Matrix SVD decomposition

This test computes an SVD decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_svd_decomposition
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Recursive hash computing

This test iteratively computes a hash chain of length `ITERATIONS_COUNT`: `hash(hash( ... hash(x)))` where `x` is the initial value specified by `INITIAL_VALUE`.

To run:

```shell
cd recursive_hash
ITERATIONS_COUNT=<iterations_count> INITIAL_VALUE=<initial_value> cargo +nightly build --release --target wasm32-unknown-unknown
```
