"use strict";
// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var utf8_1 = require("utf8");
var types_1 = require("./types");
var ZERO_64 = '0000000000000000000000000000000000000000000000000000000000000000';
/**
 * Pad an address with zeros on the left.
 *
 * @param input - The input address to pad.
 */
exports.padAddress = function (input) {
    var inputWithout0x = input.startsWith('0x') ? input.substr(2) : input;
    return ("" + ZERO_64 + inputWithout0x).slice(-64);
};
/**
 * Pad a boolean with zeros on the left.
 *
 * @param input - The input address to pad.
 */
exports.padBool = function (input) {
    return ("" + ZERO_64 + (input ? '1' : '0')).slice(-64);
};
/**
 * Pad a u32 with zeros on the left.
 *
 * @param input - The input address to pad.
 */
exports.padU32 = function (input) {
    var bn = new bignumber_js_1.default(input);
    if (bn.isNaN()) {
        throw new Error('Input is not a valid number.');
    }
    if (bn.isLessThan(0)) {
        bn = new bignumber_js_1.default('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)
            .plus(bn)
            .plus(1);
    }
    return ("" + ZERO_64 + bn.toString(16)).slice(-64);
};
/**
 * Convert an input string to bytes.
 *
 * @param input - The input string to convert.
 */
exports.stringToBytes = function (input) {
    if (types_1.isArray(input)) {
        return input;
    }
    else if (input.startsWith('0x')) {
        var matches = input
            .substr(2)
            .toLowerCase()
            .match(/.{1,2}/g) || [];
        return matches.map(function (value) { return parseInt(value, 16); });
    }
    else {
        return input.split('').map(function (char) { return char.charCodeAt(0); });
    }
};
/**
 * Pad bytes with zeros on the left.
 *
 * @param input - The input bytes to pad.
 */
exports.padBytes = function (input) {
    var inputBytes = exports.stringToBytes(input);
    return "" + exports.padU32(inputBytes.length) + exports.padFixedBytes(inputBytes);
};
/**
 * Pad fixed bytes.
 *
 * @param input - Input bytes to pad.
 */
exports.padFixedBytes = function (input) {
    var inputBytes = exports.stringToBytes(input);
    var sinput = inputBytes
        .map(function (code) { return ("0" + code.toString(16)).slice(-2); })
        .join('');
    var max = Math.floor((sinput.length + 63) / 64) * 64;
    return ("" + sinput + ZERO_64).substr(0, max);
};
/**
 * Pad string.
 *
 * @param input - String to pad.
 */
exports.padString = function (input) {
    var array = utf8_1.encode(input)
        .split('')
        .map(function (char) { return char.charCodeAt(0); });
    return exports.padBytes(array);
};
