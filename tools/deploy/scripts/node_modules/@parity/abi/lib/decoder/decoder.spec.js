"use strict";
// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var decoder_1 = require("./decoder");
var paramType_1 = require("../spec/paramType");
var token_1 = require("../token");
var pad_1 = require("../util/pad");
describe('decoder/Decoder', function () {
    var stringToBytes = function (str) {
        var matches = str.match(/.{1,2}/g);
        if (!matches) {
            throw new Error('stringToBytes: mo matches');
        }
        return matches.map(function (code) { return parseInt(code, 16); });
    };
    var address1 = '0000000000000000000000001111111111111111111111111111111111111111';
    var address2 = '0000000000000000000000002222222222222222222222222222222222222222';
    var address3 = '0000000000000000000000003333333333333333333333333333333333333333';
    var address4 = '0000000000000000000000004444444444444444444444444444444444444444';
    var bool1 = '0000000000000000000000000000000000000000000000000000000000000001';
    var bytes1 = '1234000000000000000000000000000000000000000000000000000000000000';
    var bytes2 = '1000000000000000000000000000000000000000000000000000000000000000';
    var bytes3 = '10000000000000000000000000000000000000000000000000000000000002';
    var bytes4 = '0010000000000000000000000000000000000000000000000000000000000002';
    var int1 = '0111111111111111111111111111111111111111111111111111111111111111';
    var intn = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85';
    var string1 = '6761766f66796f726b0000000000000000000000000000000000000000000000';
    var string2 = '4665726ee16e64657a0000000000000000000000000000000000000000000000';
    var tokenAddress1 = new token_1.default('address', "0x" + address1.slice(-40));
    var tokenAddress2 = new token_1.default('address', "0x" + address2.slice(-40));
    var tokenAddress3 = new token_1.default('address', "0x" + address3.slice(-40));
    var tokenAddress4 = new token_1.default('address', "0x" + address4.slice(-40));
    var tokenBool1 = new token_1.default('bool', true);
    var tokenFixedBytes1 = new token_1.default('fixedBytes', [0x12, 0x34]);
    var tokenBytes1 = new token_1.default('bytes', [0x12, 0x34]);
    var tokenBytes2 = new token_1.default('bytes', stringToBytes(bytes2).concat(stringToBytes(bytes2)));
    var tokenBytes3 = new token_1.default('bytes', stringToBytes(bytes3));
    var tokenBytes4 = new token_1.default('bytes', stringToBytes(bytes4));
    var tokenInt1 = new token_1.default('int', new bignumber_js_1.default(int1, 16));
    var tokenIntn = new token_1.default('int', new bignumber_js_1.default(-123));
    var tokenUint1 = new token_1.default('uint', new bignumber_js_1.default(int1, 16));
    var tokenUintn = new token_1.default('uint', new bignumber_js_1.default(intn, 16));
    var tokenString1 = new token_1.default('string', 'gavofyork');
    var tokenString2 = new token_1.default('string', 'Fern√°ndez');
    var slices = [address1, address2, address3, address4];
    describe('peek', function () {
        it('returns the slice at the correct position', function () {
            expect(decoder_1.default.peek(slices, 1)).toEqual(slices[1]);
        });
        it('returns empty on invalid slices', function () {
            expect(decoder_1.default.peek(null, 4)).toEqual('0000000000000000000000000000000000000000000000000000000000000000');
        });
    });
    describe('takeBytes', function () {
        it('returns a single slice', function () {
            expect(decoder_1.default.takeBytes(slices, 0, 32).bytes).toEqual(stringToBytes(slices[0]));
        });
        it('returns a single partial slice', function () {
            expect(decoder_1.default.takeBytes(slices, 0, 20).bytes).toEqual(stringToBytes(slices[0].substr(0, 40)));
        });
        it('returns multiple slices', function () {
            expect(decoder_1.default.takeBytes(slices, 0, 64).bytes).toEqual(stringToBytes("" + slices[0] + slices[1]));
        });
        it('returns a single offset slice', function () {
            expect(decoder_1.default.takeBytes(slices, 1, 32).bytes).toEqual(stringToBytes(slices[1]));
        });
        it('returns multiple offset slices', function () {
            expect(decoder_1.default.takeBytes(slices, 1, 64).bytes).toEqual(stringToBytes("" + slices[1] + slices[2]));
        });
        it('returns the requires length from slices', function () {
            expect(decoder_1.default.takeBytes(slices, 1, 75).bytes).toEqual(stringToBytes(("" + slices[1] + slices[2] + slices[3]).substr(0, 150)));
        });
        it('returns with empty inputs', function () {
            expect(decoder_1.default.takeBytes([], 0, 0).bytes).toEqual([]);
        });
    });
    describe('decodeParam', function () {
        it('throws an error on non ParamType param', function () {
            expect(function () {
                return decoder_1.default.decodeParam({}, undefined, undefined);
            }).toThrow(/ParamType/);
        });
        it('throws an error on invalid param type', function () {
            var pt = new paramType_1.default('address');
            // @ts-ignore We uglily set the type here.
            pt._type = 'noMatch';
            expect(function () { return decoder_1.default.decodeParam(pt, undefined, undefined); }).toThrow(/noMatch/);
        });
        it('decodes an address', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('address'), [address1], 0).token).toEqual(tokenAddress1);
        });
        it('decodes a bool', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('bool'), [bool1], 0).token).toEqual(tokenBool1);
        });
        it('decodes an int', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('int'), [int1], 0).token).toEqual(tokenInt1);
        });
        it('decodes a negative int', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('int'), [intn], 0).token).toEqual(tokenIntn);
        });
        it('decodes an uint', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('uint'), [int1], 0).token).toEqual(tokenUint1);
        });
        it('decodes an uint (negative as int)', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('uint'), [intn], 0).token).toEqual(tokenUintn);
        });
        it('decodes fixedBytes', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('fixedBytes', undefined, 2), [bytes1], 0).token).toEqual(tokenFixedBytes1);
        });
        it('decodes bytes', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('bytes'), [pad_1.padU32(0x20), pad_1.padU32(2), bytes1], 0).token).toEqual(tokenBytes1);
        });
        it('decodes string', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('string'), [pad_1.padU32(0x20), pad_1.padU32(9), string1], 0).token).toEqual(tokenString1);
        });
        it('decodes utf8-invalid string', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('string'), [pad_1.padU32(0x20), pad_1.padU32(9), string2], 0).token).toEqual(tokenString2);
        });
        it('decodes string (indexed)', function () {
            expect(decoder_1.default.decodeParam(new paramType_1.default('string', undefined, 0, true), [bytes1], 0)).toEqual(decoder_1.default.decodeParam(new paramType_1.default('fixedBytes', undefined, 32, true), [bytes1], 0));
        });
    });
    describe('decode', function () {
        it('throws an error on invalid params', function () {
            expect(function () { return decoder_1.default.decode(undefined, '123'); }).toThrow(/array/);
        });
        describe('address', function () {
            it('decodes an address', function () {
                expect(decoder_1.default.decode([new paramType_1.default('address')], "" + address1)).toEqual([tokenAddress1]);
            });
            it('decodes 2 addresses', function () {
                expect(decoder_1.default.decode([new paramType_1.default('address'), new paramType_1.default('address')], "" + address1 + address2)).toEqual([tokenAddress1, tokenAddress2]);
            });
            it('decodes a fixedArray of addresses', function () {
                expect(decoder_1.default.decode([new paramType_1.default('fixedArray', new paramType_1.default('address'), 2)], "" + address1 + address2)).toEqual([new token_1.default('fixedArray', [tokenAddress1, tokenAddress2])]);
            });
            it('decodes a dynamic array of addresses', function () {
                expect(decoder_1.default.decode([new paramType_1.default('array', new paramType_1.default('address'))], "" + pad_1.padU32(0x20) + pad_1.padU32(2) + address1 + address2)).toEqual([new token_1.default('array', [tokenAddress1, tokenAddress2])]);
            });
            it('decodes a dynamic array of fixed arrays', function () {
                expect(decoder_1.default.decode([
                    new paramType_1.default('array', new paramType_1.default('fixedArray', new paramType_1.default('address'), 2))
                ], "" + pad_1.padU32(0x20) + pad_1.padU32(2) + address1 + address2 + address3 + address4)).toEqual([
                    new token_1.default('array', [
                        new token_1.default('fixedArray', [tokenAddress1, tokenAddress2]),
                        new token_1.default('fixedArray', [tokenAddress3, tokenAddress4])
                    ])
                ]);
            });
        });
        describe('int', function () {
            it('decodes an int', function () {
                expect(decoder_1.default.decode([new paramType_1.default('int')], "" + int1)).toEqual([
                    tokenInt1
                ]);
            });
        });
        describe('uint', function () {
            it('decodes an uint', function () {
                expect(decoder_1.default.decode([new paramType_1.default('uint')], "" + int1)).toEqual([
                    tokenUint1
                ]);
            });
        });
        describe('fixedBytes', function () {
            it('decodes fixedBytes', function () {
                expect(decoder_1.default.decode([new paramType_1.default('fixedBytes', undefined, 2)], "" + bytes1)).toEqual([tokenFixedBytes1]);
            });
        });
        describe('bytes', function () {
            it('decodes bytes', function () {
                expect(decoder_1.default.decode([new paramType_1.default('bytes')], "" + pad_1.padU32(0x20) + pad_1.padU32(2) + bytes1)).toEqual([tokenBytes1]);
            });
            it('decodes bytes sequence', function () {
                expect(decoder_1.default.decode([new paramType_1.default('bytes')], "" + pad_1.padU32(0x20) + pad_1.padU32(0x40) + bytes2 + bytes2)).toEqual([tokenBytes2]);
            });
            it('decodes bytes seuence (2)', function () {
                expect(decoder_1.default.decode([new paramType_1.default('bytes'), new paramType_1.default('bytes')], "" + pad_1.padU32(0x40) + pad_1.padU32(0x80) + pad_1.padU32(0x1f) + bytes3 + "00" + pad_1.padU32(0x20) + bytes4)).toEqual([tokenBytes3, tokenBytes4]);
            });
        });
        describe('bool', function () {
            it('decodes a single bool', function () {
                expect(decoder_1.default.decode([new paramType_1.default('bool')], bool1)).toEqual([
                    tokenBool1
                ]);
            });
        });
        describe('string', function () {
            it('decodes a string', function () {
                expect(decoder_1.default.decode([new paramType_1.default('string')], "" + pad_1.padU32(0x20) + pad_1.padU32(9) + string1)).toEqual([tokenString1]);
            });
        });
    });
});
