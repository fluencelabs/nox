"use strict";
// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var utf8 = require("utf8");
var token_1 = require("../token/token");
var bytesTaken_1 = require("./bytesTaken");
var decodeResult_1 = require("./decodeResult");
var paramType_1 = require("../spec/paramType/paramType");
var slice_1 = require("../util/slice");
var sliceAs_1 = require("../util/sliceAs");
var types_1 = require("../util/types");
var NULL = '0000000000000000000000000000000000000000000000000000000000000000';
var Decoder = /** @class */ (function () {
    function Decoder() {
    }
    Decoder.decode = function (params, data) {
        if (!types_1.isArray(params)) {
            throw new Error('Parameters should be array of ParamType');
        }
        var slices = slice_1.sliceData(data);
        var offset = 0;
        return params.map(function (param) {
            var result = Decoder.decodeParam(param, slices, offset);
            offset = result.newOffset;
            return result.token;
        });
    };
    Decoder.peek = function (slices, position) {
        if (!slices || !slices[position]) {
            return NULL;
        }
        return slices[position];
    };
    Decoder.takeBytes = function (slices, position, length) {
        var slicesLength = Math.floor((length + 31) / 32);
        var bytesStr = '';
        for (var index = 0; index < slicesLength; index++) {
            bytesStr = "" + bytesStr + Decoder.peek(slices, position + index);
        }
        var bytes = (bytesStr.substr(0, length * 2).match(/.{1,2}/g) || []).map(function (code) { return parseInt(code, 16); });
        return new bytesTaken_1.default(bytes, position + slicesLength);
    };
    Decoder.decodeParam = function (param, slices, offset) {
        if (offset === void 0) { offset = 0; }
        if (!types_1.isInstanceOf(param, paramType_1.default)) {
            throw new Error('param should be instanceof ParamType');
        }
        var tokens = [];
        var taken;
        var lengthOffset;
        var length;
        var newOffset;
        switch (param.type) {
            case 'address':
                return new decodeResult_1.default(new token_1.default(param.type, sliceAs_1.asAddress(Decoder.peek(slices, offset))), offset + 1);
            case 'bool':
                return new decodeResult_1.default(new token_1.default(param.type, sliceAs_1.asBool(Decoder.peek(slices, offset))), offset + 1);
            case 'int':
                return new decodeResult_1.default(new token_1.default(param.type, sliceAs_1.asI32(Decoder.peek(slices, offset))), offset + 1);
            case 'uint':
                return new decodeResult_1.default(new token_1.default(param.type, sliceAs_1.asU32(Decoder.peek(slices, offset))), offset + 1);
            case 'fixedBytes': {
                taken = Decoder.takeBytes(slices, offset, param.length);
                return new decodeResult_1.default(new token_1.default(param.type, taken.bytes), taken.newOffset);
            }
            case 'bytes': {
                lengthOffset = sliceAs_1.asU32(Decoder.peek(slices, offset))
                    .div(32)
                    .toNumber();
                length = sliceAs_1.asU32(Decoder.peek(slices, lengthOffset)).toNumber();
                taken = Decoder.takeBytes(slices, lengthOffset + 1, length);
                return new decodeResult_1.default(new token_1.default(param.type, taken.bytes), offset + 1);
            }
            case 'string': {
                if (param.indexed) {
                    taken = Decoder.takeBytes(slices, offset, 32);
                    return new decodeResult_1.default(new token_1.default('fixedBytes', taken.bytes), offset + 1);
                }
                lengthOffset = sliceAs_1.asU32(Decoder.peek(slices, offset))
                    .div(32)
                    .toNumber();
                length = sliceAs_1.asU32(Decoder.peek(slices, lengthOffset)).toNumber();
                taken = Decoder.takeBytes(slices, lengthOffset + 1, length);
                var str = taken.bytes
                    .map(function (code) { return String.fromCharCode(code); })
                    .join('');
                var decoded = void 0;
                try {
                    decoded = utf8.decode(str);
                }
                catch (error) {
                    decoded = str;
                }
                return new decodeResult_1.default(new token_1.default(param.type, decoded), offset + 1);
            }
            case 'array': {
                if (!param.subtype) {
                    throw new Error("decodeParam: param of type '" + param.type + "' must have a subtype");
                }
                lengthOffset = sliceAs_1.asU32(Decoder.peek(slices, offset))
                    .div(32)
                    .toNumber();
                length = sliceAs_1.asU32(Decoder.peek(slices, lengthOffset)).toNumber();
                newOffset = lengthOffset + 1;
                for (var index = 0; index < length; index++) {
                    var result = Decoder.decodeParam(param.subtype, slices, newOffset);
                    newOffset = result.newOffset;
                    tokens.push(result.token);
                }
                return new decodeResult_1.default(new token_1.default(param.type, tokens), offset + 1);
            }
            case 'fixedArray': {
                if (!param.subtype) {
                    throw new Error("decodeParam: param of type '" + param.type + "' must have a subtype");
                }
                newOffset = offset;
                for (var index = 0; index < param.length; index++) {
                    var result = Decoder.decodeParam(param.subtype, slices, newOffset);
                    newOffset = result.newOffset;
                    tokens.push(result.token);
                }
                return new decodeResult_1.default(new token_1.default(param.type, tokens), newOffset);
            }
            default:
                throw new Error("Invalid param type " + param.type + " in decodeParam");
        }
    };
    return Decoder;
}());
exports.default = Decoder;
