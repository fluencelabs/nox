"use strict";
// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var encoder_1 = require("./encoder");
var token_1 = require("../token");
var pad_1 = require("../util/pad");
describe('encoder/Encoder', function () {
    describe('encodeToken', function () {
        it('requires token as Token', function () {
            expect(function () { return encoder_1.default.encodeToken(undefined); }).toThrow(/Token/);
        });
        it('encodes address tokens in Mediate(raw)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('address', '123'));
            expect(mediate.type).toEqual('raw');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes bool tokens in Mediate(raw)', function () {
            var mediatet = encoder_1.default.encodeToken(new token_1.default('bool', true));
            var mediatef = encoder_1.default.encodeToken(new token_1.default('bool', false));
            expect(mediatet.type).toEqual('raw');
            expect(mediatet.value).toBeTruthy();
            expect(mediatef.type).toEqual('raw');
            expect(mediatef.value).toBeTruthy();
        });
        it('encodes int tokens in Mediate(raw)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('int', '123'));
            expect(mediate.type).toEqual('raw');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes uint tokens in Mediate(raw)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('uint', '123'));
            expect(mediate.type).toEqual('raw');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes fixedBytes tokens in Mediate(raw)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('fixedBytes', '123'));
            expect(mediate.type).toEqual('raw');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes bytes tokens in Mediate(prefixed)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('bytes', '123'));
            expect(mediate.type).toEqual('prefixed');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes string tokens in Mediate(prefixed)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('string', '123'));
            expect(mediate.type).toEqual('prefixed');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes fixedArray tokens in Mediate(fixedArray)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('fixedArray', [new token_1.default('uint', '123')]));
            expect(mediate.type).toEqual('fixedArray');
            expect(mediate.value).toBeTruthy();
        });
        it('encodes array tokens in Mediate(array)', function () {
            var mediate = encoder_1.default.encodeToken(new token_1.default('array', [new token_1.default('uint', '123')]));
            expect(mediate.type).toEqual('array');
            expect(mediate.value).toBeTruthy();
        });
        it('throws an Error on invalid tokens', function () {
            var token = new token_1.default('address');
            // @ts-ignore We uglily set the Token type here.
            token._type = 'noMatch';
            expect(function () { return encoder_1.default.encodeToken(token); }).toThrow(/noMatch/);
        });
        it('throws and error on invalid value tokens', function () {
            var token = new token_1.default('uint');
            // @ts-ignore We uglily set the Token value here.
            token._value = 'invalidNumber';
            expect(function () { return encoder_1.default.encodeToken(token); }).toThrow(/Cannot encode/);
        });
    });
    describe('encode', function () {
        it('requires tokens array', function () {
            expect(function () { return encoder_1.default.encode(undefined); }).toThrow(/array/);
        });
        describe('addresses', function () {
            var address1 = '1111111111111111111111111111111111111111';
            var address2 = '2222222222222222222222222222222222222222';
            var address3 = '3333333333333333333333333333333333333333';
            var address4 = '4444444444444444444444444444444444444444';
            var encAddress1 = pad_1.padAddress(address1);
            var encAddress2 = pad_1.padAddress(address2);
            var encAddress3 = pad_1.padAddress(address3);
            var encAddress4 = pad_1.padAddress(address4);
            var tokenAddress1 = new token_1.default('address', address1);
            var tokenAddress2 = new token_1.default('address', address2);
            var tokenAddress3 = new token_1.default('address', address3);
            var tokenAddress4 = new token_1.default('address', address4);
            it('encodes an address', function () {
                var token = tokenAddress1;
                expect(encoder_1.default.encode([token])).toEqual(encAddress1);
            });
            it('encodes an array of addresses', function () {
                var expected = "" + pad_1.padU32(0x20) + pad_1.padU32(2) + encAddress1 + encAddress2;
                var token = new token_1.default('array', [tokenAddress1, tokenAddress2]);
                expect(encoder_1.default.encode([token])).toEqual(expected);
            });
            it('encodes an fixedArray of addresses', function () {
                var expected = "" + encAddress1 + encAddress2;
                var token = new token_1.default('fixedArray', [tokenAddress1, tokenAddress2]);
                expect(encoder_1.default.encode([token])).toEqual(expected);
            });
            it('encodes two addresses', function () {
                var expected = "" + encAddress1 + encAddress2;
                var tokens = [tokenAddress1, tokenAddress2];
                expect(encoder_1.default.encode(tokens)).toEqual(expected);
            });
            it('encodes fixed array of dynamic array addresses', function () {
                var tokens1 = new token_1.default('array', [tokenAddress1, tokenAddress2]);
                var tokens2 = new token_1.default('array', [tokenAddress3, tokenAddress4]);
                var fixed = new token_1.default('fixedArray', [tokens1, tokens2]);
                var expected = "" + pad_1.padU32(0x40) + pad_1.padU32(0xa0) + pad_1.padU32(2) + encAddress1 + encAddress2 + pad_1.padU32(2) + encAddress3 + encAddress4;
                expect(encoder_1.default.encode([fixed])).toEqual(expected);
            });
            it('encodes dynamic array of fixed array addresses', function () {
                var tokens1 = new token_1.default('fixedArray', [tokenAddress1, tokenAddress2]);
                var tokens2 = new token_1.default('fixedArray', [tokenAddress3, tokenAddress4]);
                var dynamic = new token_1.default('array', [tokens1, tokens2]);
                var expected = "" + pad_1.padU32(0x20) + pad_1.padU32(2) + encAddress1 + encAddress2 + encAddress3 + encAddress4;
                expect(encoder_1.default.encode([dynamic])).toEqual(expected);
            });
            it('encodes dynamic array of dynamic array addresses', function () {
                var tokens1 = new token_1.default('array', [tokenAddress1]);
                var tokens2 = new token_1.default('array', [tokenAddress2]);
                var dynamic = new token_1.default('array', [tokens1, tokens2]);
                var expected = "" + pad_1.padU32(0x20) + pad_1.padU32(2) + pad_1.padU32(0x80) + pad_1.padU32(0xc0) + pad_1.padU32(1) + encAddress1 + pad_1.padU32(1) + encAddress2;
                expect(encoder_1.default.encode([dynamic])).toEqual(expected);
            });
            it('encodes dynamic array of dynamic array addresses (2)', function () {
                var tokens1 = new token_1.default('array', [tokenAddress1, tokenAddress2]);
                var tokens2 = new token_1.default('array', [tokenAddress3, tokenAddress4]);
                var dynamic = new token_1.default('array', [tokens1, tokens2]);
                var expected = "" + pad_1.padU32(0x20) + pad_1.padU32(2) + pad_1.padU32(0x80) + pad_1.padU32(0xe0) + pad_1.padU32(2) + encAddress1 + encAddress2 + pad_1.padU32(2) + encAddress3 + encAddress4;
                expect(encoder_1.default.encode([dynamic])).toEqual(expected);
            });
            it('encodes fixed array of fixed array addresses', function () {
                var tokens1 = new token_1.default('fixedArray', [tokenAddress1, tokenAddress2]);
                var tokens2 = new token_1.default('fixedArray', [tokenAddress3, tokenAddress4]);
                var dynamic = new token_1.default('fixedArray', [tokens1, tokens2]);
                var expected = "" + encAddress1 + encAddress2 + encAddress3 + encAddress4;
                expect(encoder_1.default.encode([dynamic])).toEqual(expected);
            });
        });
        describe('bytes', function () {
            var bytes1 = '0x1234';
            var bytes2 = '0x10000000000000000000000000000000000000000000000000000000000002';
            var bytes3 = '0x1000000000000000000000000000000000000000000000000000000000000000';
            it('encodes fixed bytes', function () {
                var token = new token_1.default('fixedBytes', bytes1);
                expect(encoder_1.default.encode([token])).toEqual(pad_1.padFixedBytes(bytes1));
            });
            it('encodes bytes', function () {
                var token = new token_1.default('bytes', bytes1);
                expect(encoder_1.default.encode([token])).toEqual("" + pad_1.padU32(0x20) + pad_1.padU32(2) + pad_1.padFixedBytes(bytes1));
            });
            it('encodes bytes (short of boundary)', function () {
                var token = new token_1.default('bytes', bytes2);
                expect(encoder_1.default.encode([token])).toEqual("" + pad_1.padU32(0x20) + pad_1.padU32(0x1f) + pad_1.padFixedBytes(bytes2));
            });
            it('encodes bytes (two blocks)', function () {
                var input = "" + bytes3 + bytes3.slice(-64);
                var token = new token_1.default('bytes', input);
                expect(encoder_1.default.encode([token])).toEqual("" + pad_1.padU32(0x20) + pad_1.padU32(0x40) + pad_1.padFixedBytes(input));
            });
            it('encodes two consecutive bytes', function () {
                var in1 = '0x10000000000000000000000000000000000000000000000000000000000002';
                var in2 = '0x0010000000000000000000000000000000000000000000000000000000000002';
                var tokens = [new token_1.default('bytes', in1), new token_1.default('bytes', in2)];
                expect(encoder_1.default.encode(tokens)).toEqual("" + pad_1.padU32(0x40) + pad_1.padU32(0x80) + pad_1.padU32(0x1f) + pad_1.padFixedBytes(in1) + pad_1.padU32(0x20) + pad_1.padFixedBytes(in2));
            });
        });
        describe('string', function () {
            it('encodes a string', function () {
                var baseString = 'gavofyork';
                var stringEnc = pad_1.padFixedBytes('0x6761766f66796f726b');
                var token = new token_1.default('string', baseString);
                expect(encoder_1.default.encode([token])).toEqual("" + pad_1.padU32(0x20) + pad_1.padU32(baseString.length.toString(16)) + stringEnc);
            });
        });
        describe('uint', function () {
            it('encodes a uint', function () {
                var token = new token_1.default('uint', 4);
                expect(encoder_1.default.encode([token])).toEqual(pad_1.padU32(4));
            });
        });
        describe('int', function () {
            it('encodes a int', function () {
                var token = new token_1.default('int', 4);
                expect(encoder_1.default.encode([token])).toEqual(pad_1.padU32(4));
            });
        });
        describe('bool', function () {
            it('encodes a bool (true)', function () {
                var token = new token_1.default('bool', true);
                expect(encoder_1.default.encode([token])).toEqual(pad_1.padU32(1));
            });
            it('encodes a bool (false)', function () {
                var token = new token_1.default('bool', false);
                expect(encoder_1.default.encode([token])).toEqual(pad_1.padU32(0));
            });
        });
        describe('comprehensive test', function () {
            it('encodes a complex sequence', function () {
                var bytes = '0x131a3afc00d1b1e3461b955e53fc866dcf303b3eb9f4c16f89e388930f48134b131a3afc00d1b1e3461b955e53fc866dcf303b3eb9f4c16f89e388930f48134b';
                var tokens = [
                    new token_1.default('int', 5),
                    new token_1.default('bytes', bytes),
                    new token_1.default('int', 3),
                    new token_1.default('bytes', bytes)
                ];
                expect(encoder_1.default.encode(tokens)).toEqual("" + pad_1.padU32(5) + pad_1.padU32(0x80) + pad_1.padU32(3) + pad_1.padU32(0xe0) + pad_1.padU32(0x40) + bytes.substr(2) + pad_1.padU32(0x40) + bytes.substr(2));
            });
            it('encodes a complex sequence (nested)', function () {
                var array = [
                    new token_1.default('int', 5),
                    new token_1.default('int', 6),
                    new token_1.default('int', 7)
                ];
                var tokens = [
                    new token_1.default('int', 1),
                    new token_1.default('string', 'gavofyork'),
                    new token_1.default('int', 2),
                    new token_1.default('int', 3),
                    new token_1.default('int', 4),
                    new token_1.default('array', array)
                ];
                var stringEnc = pad_1.padFixedBytes('0x6761766f66796f726b');
                expect(encoder_1.default.encode(tokens)).toEqual("" + pad_1.padU32(1) + pad_1.padU32(0xc0) + pad_1.padU32(2) + pad_1.padU32(3) + pad_1.padU32(4) + pad_1.padU32(0x100) + pad_1.padU32(9) + stringEnc + pad_1.padU32(3) + pad_1.padU32(5) + pad_1.padU32(6) + pad_1.padU32(7));
            });
        });
    });
});
