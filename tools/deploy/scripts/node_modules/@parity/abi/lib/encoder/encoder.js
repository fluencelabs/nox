"use strict";
// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var pad_1 = require("../util/pad");
var mediate_1 = require("./mediate");
var token_1 = require("../token/token");
var types_1 = require("../util/types");
var Encoder = /** @class */ (function () {
    function Encoder() {
    }
    Encoder.encode = function (tokens) {
        if (!types_1.isArray(tokens)) {
            throw new Error('tokens should be array of Token');
        }
        var mediates = tokens.map(function (token, index) {
            return Encoder.encodeToken(token, index);
        });
        var inits = mediates
            .map(function (mediate, index) { return mediate.init(mediate_1.default.offsetFor(mediates, index)); })
            .join('');
        var closings = mediates
            .map(function (mediate, index) {
            return mediate.closing(mediate_1.default.offsetFor(mediates, index));
        })
            .join('');
        return "" + inits + closings;
    };
    Encoder.encodeToken = function (token, index) {
        if (index === void 0) { index = 0; }
        if (!token || !types_1.isInstanceOf(token, token_1.default)) {
            throw new Error('token should be instanceof Token');
        }
        try {
            switch (token.type) {
                case 'address':
                    return new mediate_1.default('raw', pad_1.padAddress(token.value));
                case 'int':
                case 'uint':
                    return new mediate_1.default('raw', pad_1.padU32(token.value));
                case 'bool':
                    return new mediate_1.default('raw', pad_1.padBool(token.value));
                case 'fixedBytes':
                    return new mediate_1.default('raw', pad_1.padFixedBytes(token.value));
                case 'bytes':
                    return new mediate_1.default('prefixed', pad_1.padBytes(token.value));
                case 'string':
                    return new mediate_1.default('prefixed', pad_1.padString(token.value));
                case 'fixedArray':
                case 'array':
                    return new mediate_1.default(token.type, 
                    // TODO token.value as Token[] seems weird.
                    token.value.map(function (token) { return Encoder.encodeToken(token); }));
            }
        }
        catch (e) {
            throw new Error("Cannot encode token #" + index + " [" + token.type + ": " + token.value + "]. " + e.message);
        }
        throw new Error("Invalid token type " + token.type + " in encodeToken");
    };
    return Encoder;
}());
exports.default = Encoder;
