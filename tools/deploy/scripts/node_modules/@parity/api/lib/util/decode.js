"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = require("@parity/abi/lib/spec/paramType/format");
var function_1 = require("@parity/abi/lib/spec/function");
var types_1 = require("./types");
/**
 * Decode call data.
 *
 * @param data - The call data to decode.
 */
exports.decodeCallData = function (data) {
    if (!types_1.isHex(data)) {
        throw new Error('Input to decodeCallData should be a hex value');
    }
    if (data.startsWith('0x')) {
        return exports.decodeCallData(data.slice(2));
    }
    if (data.length < 8) {
        throw new Error('Input to decodeCallData should be method signature + data');
    }
    var signature = data.substr(0, 8);
    var paramdata = data.substr(8);
    return {
        signature: "0x" + signature,
        paramdata: "0x" + paramdata
    };
};
/**
 * Decode the method inputs.
 *
 * @param methodAbi - The ABI of the method.
 * @param paramdata -
 */
exports.decodeMethodInput = function (methodAbi, paramdata) {
    if (!methodAbi) {
        throw new Error('decodeMethodInput should receive valid method-specific ABI');
    }
    if (paramdata && paramdata.length) {
        if (!types_1.isHex(paramdata)) {
            throw new Error('Input to decodeMethodInput should be a hex value');
        }
        if (paramdata.substr(0, 2) === '0x') {
            return exports.decodeMethodInput(methodAbi, paramdata.slice(2));
        }
    }
    return new function_1.default(methodAbi)
        .decodeInput(paramdata)
        .map(function (decoded) { return decoded.value; });
};
/**
 * Takes a method in form name(...,types) and returns the inferred abi definition.
 *
 * @param method - The method to convert to abi.
 */
exports.methodToAbi = function (method) {
    var length = method.length;
    var typesStart = method.indexOf('(');
    var typesEnd = method.indexOf(')');
    if (typesStart === -1) {
        throw new Error("Missing start ( in call to decodeMethod with " + method);
    }
    else if (typesEnd === -1) {
        throw new Error("Missing end ) in call to decodeMethod with " + method);
    }
    else if (typesEnd < typesStart) {
        throw new Error("End ) is before start ( in call to decodeMethod with " + method);
    }
    else if (typesEnd !== length - 1) {
        throw new Error("Extra characters after end ) in call to decodeMethod with " + method);
    }
    var name = method.substr(0, typesStart);
    var types = method
        .substr(typesStart + 1, length - (typesStart + 1) - 1)
        .split(',');
    var inputs = types
        .filter(function (_type) { return _type.length; })
        .map(function (_type) {
        var type = format_1.fromParamType(format_1.toParamType(_type));
        return { type: type };
    });
    return { type: 'function', name: name, inputs: inputs };
};
/**
 * Decode fata from an ABI.
 *
 * @param inputTypes - The types of the inputs.
 * @param data - The data passed to this ABI.
 */
exports.abiDecode = function (inputTypes, data) {
    return exports.decodeMethodInput({
        inputs: inputTypes.map(function (type) {
            return { type: type };
        })
    }, data);
};
