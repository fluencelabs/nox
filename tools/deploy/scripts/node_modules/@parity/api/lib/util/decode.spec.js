"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var decode_1 = require("./decode");
describe('util/decode', function () {
    var METH = '0x70a08231';
    var ENCO = '0x70a082310000000000000000000000005A5eFF38DA95b0D58b6C616f2699168B480953C9';
    var DATA = '0x0000000000000000000000005A5eFF38DA95b0D58b6C616f2699168B480953C9';
    describe('decodeCallData', function () {
        it('throws on non-hex inputs', function () {
            expect(function () { return decode_1.decodeCallData('invalid'); }).toThrow(/should be a hex value/);
        });
        it('throws when invalid signature length', function () {
            expect(function () { return decode_1.decodeCallData(METH.slice(-6)); }).toThrow(/should be method signature/);
        });
        it('splits valid inputs properly', function () {
            expect(decode_1.decodeCallData(ENCO)).toEqual({
                signature: METH,
                paramdata: DATA
            });
        });
    });
    describe('decodeMethodInput', function () {
        it('expects a valid ABI', function () {
            expect(function () { return decode_1.decodeMethodInput(null, null); }).toThrow(/should receive valid method/);
        });
        it('expects valid hex parameter data', function () {
            expect(function () { return decode_1.decodeMethodInput({}, 'invalid'); }).toThrow(/should be a hex value/);
        });
        it('correct decodes null inputs', function () {
            expect(decode_1.decodeMethodInput({})).toEqual([]);
        });
        it('correct decodes empty inputs', function () {
            expect(decode_1.decodeMethodInput({}, '')).toEqual([]);
        });
        it('correctly decodes valid inputs', function () {
            expect(decode_1.decodeMethodInput({
                type: 'function',
                inputs: [{ type: 'uint' }]
            }, DATA)).toEqual([new bignumber_js_1.default('0x5a5eff38da95b0d58b6c616f2699168b480953c9')]);
        });
    });
    describe('methodToAbi', function () {
        it('throws when no start ( specified', function () {
            expect(function () { return decode_1.methodToAbi('invalid,uint,bool)'); }).toThrow(/Missing start \(/);
        });
        it('throws when no end ) specified', function () {
            expect(function () { return decode_1.methodToAbi('invalid(uint,bool'); }).toThrow(/Missing end \)/);
        });
        it('throws when end ) is not in the last position', function () {
            expect(function () { return decode_1.methodToAbi('invalid(uint,bool)2'); }).toThrow(/Extra characters after end \)/);
        });
        it('throws when start ( is after end )', function () {
            expect(function () { return decode_1.methodToAbi('invalid)uint,bool('); }).toThrow(/End \) is before start \(/);
        });
        it('throws when invalid types are present', function () {
            expect(function () { return decode_1.methodToAbi('method(invalidType,bool,uint)'); }).toThrow(/Cannot convert invalidType/);
        });
        it('returns a valid methodabi for a valid method', function () {
            expect(decode_1.methodToAbi('valid(uint,bool)')).toEqual({
                type: 'function',
                name: 'valid',
                inputs: [{ type: 'uint256' }, { type: 'bool' }]
            });
        });
    });
    describe('abiDecode', function () {
        it('correctly decodes valid inputs', function () {
            expect(decode_1.abiDecode(['uint'], DATA)).toEqual([
                new bignumber_js_1.default('0x5a5eff38da95b0d58b6c616f2699168b480953c9')
            ]);
        });
    });
});
