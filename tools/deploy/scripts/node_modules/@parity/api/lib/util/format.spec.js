"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = require("./format");
describe('util/format', function () {
    /**
     * @test {bytesToHex}
     */
    describe('bytesToHex', function () {
        it('correctly converts an empty array', function () {
            expect(format_1.bytesToHex([])).toEqual('0x');
        });
        it('correctly converts a non-empty array', function () {
            expect(format_1.bytesToHex([0, 15, 16])).toEqual('0x000f10');
        });
    });
    /**
     * @test {cleanupValue}
     */
    describe('cleanupValue', function () {
        it('returns unknown values as the original', function () {
            expect(format_1.cleanupValue('original', 'unknown')).toEqual('original');
        });
        it('returns ascii arrays as ascii', function () {
            expect(format_1.cleanupValue([97, 115, 99, 105, 105, 0], 'bytes32')).toEqual('ascii');
        });
        it('returns non-ascii arrays as hex strings', function () {
            expect(format_1.cleanupValue([97, 200, 0, 0], 'bytes4')).toEqual('0x61c80000');
        });
        it('returns uint (>48) as the original', function () {
            expect(format_1.cleanupValue('original', 'uint49')).toEqual('original');
        });
        it('returns uint (<=48) as the number value', function () {
            expect(format_1.cleanupValue('12345', 'uint48')).toEqual(12345);
        });
    });
    /**
     * @test {hexToBytes}
     */
    describe('hexToBytes', function () {
        it('correctly converts an empty string', function () {
            expect(format_1.hexToBytes('')).toEqual([]);
            expect(format_1.hexToBytes('0x')).toEqual([]);
        });
        it('correctly converts a non-empty string', function () {
            expect(format_1.hexToBytes('0x000f10')).toEqual([0, 15, 16]);
        });
    });
    /**
     * @test {asciiToHex}
     */
    describe('asciiToHex', function () {
        it('correctly converts an empty string', function () {
            expect(format_1.asciiToHex('')).toEqual('0x');
        });
        it('correctly converts a non-empty string', function () {
            expect(format_1.asciiToHex('abc')).toEqual('0x616263');
            expect(format_1.asciiToHex('a\nb')).toEqual('0x610a62');
        });
        it('correctly converts where charCode < 0x10', function () {
            expect(format_1.asciiToHex([32, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
                .map(function (v) { return String.fromCharCode(v); })
                .join(''))).toEqual('0x20100f0e0d0c0b0a09080706050403020100');
        });
    });
    /**
     * @test {hexToAscii}
     */
    describe('hexToAscii', function () {
        it('correctly converts an empty string', function () {
            expect(format_1.hexToAscii('')).toEqual('');
            expect(format_1.hexToAscii('0x')).toEqual('');
        });
        it('correctly converts a non-empty string', function () {
            expect(format_1.hexToAscii('0x616263')).toEqual('abc');
        });
    });
    /**
     * @test {bytesToAscii}
     */
    describe('bytesToAscii', function () {
        it('correctly converts an empty string', function () {
            expect(format_1.bytesToAscii([])).toEqual('');
        });
        it('correctly converts a non-empty string', function () {
            expect(format_1.bytesToAscii([97, 98, 99])).toEqual('abc');
        });
    });
    /**
     * @test {padLeft}
     */
    describe('padLeft', function () {
        it('correctly pads to the number of hex digits', function () {
            expect(format_1.padLeft('ab', 4)).toEqual('0x000000ab');
        });
    });
    /**
     * @test {padRight}
     */
    describe('padRight', function () {
        it('correctly pads to the number of hex digits', function () {
            expect(format_1.padRight('ab', 4)).toEqual('0xab000000');
        });
    });
});
