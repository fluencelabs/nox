"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
/**
 * Convert a bytes array to a hexadecimal string.
 *
 * @param bytes - The bytes array to convert to hexadecimal.
 */
exports.bytesToHex = function (bytes) {
    return '0x' + Buffer.from(bytes).toString('hex');
};
/**
 * Clean the value if it's cleanable:
 * - ASCII arrays are returned as ASCII strings
 * - non-ASCII arrays are converted to hex
 * - uint (<=48) are converted to numbers
 *
 * @param value - The value to clean.
 * @param type - The type of the value.
 */
exports.cleanupValue = function (value, type) {
    // TODO: make work with arbitrary depth arrays
    if (value instanceof Array && type.match(/bytes[0-9]+/)) {
        // figure out if it's an ASCII string hiding in there:
        var ascii = '';
        var ended = false;
        for (var index = 0; index < value.length && ascii !== null; ++index) {
            var val = value[index];
            if (val === 0) {
                ended = true;
            }
            else {
                ascii += String.fromCharCode(val);
            }
            if ((ended && val !== 0) || (!ended && (val < 32 || val >= 128))) {
                ascii = null;
            }
        }
        value = ascii === null ? exports.bytesToHex(value) : ascii;
    }
    if (type.substr(0, 4) === 'uint' && +type.substr(4) <= 48) {
        value = +value;
    }
    return value;
};
/**
 * Convert a hexadecimal string to a bytes array.
 *
 * @param hex - The hex string to convert.
 */
exports.hexToBytes = function (hex) {
    var raw = exports.toHex(hex).slice(2);
    var bytes = [];
    for (var i = 0; i < raw.length; i += 2) {
        bytes.push(parseInt(raw.substr(i, 2), 16));
    }
    return bytes;
};
/**
 * Convert a hexadecimal string to an ASCII string.
 *
 * @param hex - The hex string to convert.
 */
exports.hexToAscii = function (hex) {
    var bytes = exports.hexToBytes(hex);
    var str = bytes.map(function (byte) { return String.fromCharCode(byte); }).join('');
    return str;
};
/**
 * Convert a bytes array to an ASCII string.
 *
 * @param bytes - The bytes array to convert.
 */
exports.bytesToAscii = function (bytes) {
    return bytes.map(function (b) { return String.fromCharCode(b % 512); }).join('');
};
/**
 * Convert an ASCII string to a hexadecimal string.
 *
 * @param string - The ASCII string to convert.
 */
exports.asciiToHex = function (baseString) {
    var result = '0x';
    for (var i = 0; i < baseString.length; ++i) {
        result += ('0' + baseString.charCodeAt(i).toString(16)).substr(-2);
    }
    return result;
};
/**
 * Pad the input string with `length` zeros on the right.
 *
 * @param input - The input string to pad.
 * @param length - The number of zeros to pad.
 */
exports.padRight = function (input, length) {
    var hexLength = length * 2;
    var value = exports.toHex(input).substr(2, hexLength);
    return ('0x' +
        value +
        lodash_1.range(hexLength - value.length)
            .map(function () { return '0'; })
            .join(''));
};
/**
 * Pad the input string with `length` zeros on the left.
 *
 * @param input - The input string to pad.
 * @param length - The number of zeros to pad.
 */
exports.padLeft = function (input, length) {
    var hexLength = length * 2;
    var value = exports.toHex(input).substr(2, hexLength);
    return ('0x' +
        lodash_1.range(hexLength - value.length)
            .map(function () { return '0'; })
            .join('') +
        value);
};
/**
 * Convert a string to hexadecimal.
 *
 * @param str - The string to convert.
 */
exports.toHex = function (str) {
    if (str && str.toString) {
        // TODO string has no toString(16)
        // @ts-ignore
        str = str.toString(16);
    }
    if (str && str.substr(0, 2) === '0x') {
        return str.toLowerCase();
    }
    return "0x" + (str || '').toLowerCase();
};
