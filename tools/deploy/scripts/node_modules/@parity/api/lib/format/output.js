"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
//
// SPDX-License-Identifier: MIT
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var types_1 = require("@parity/abi/lib/util/types");
var address_1 = require("@parity/abi/lib/util/address");
function outAccountInfo(infos) {
    return Object.keys(infos).reduce(function (ret, _address) {
        var info = infos[_address];
        var address = outAddress(_address);
        ret[address] = {
            name: info.name
        };
        if (info.meta) {
            ret[address].uuid = info.uuid;
            try {
                ret[address].meta = JSON.parse(info.meta);
            }
            catch (e) {
                console.error("Couldn't parse meta field of JSON key file " + info.uuid);
            }
        }
        return ret;
    }, {});
}
exports.outAccountInfo = outAccountInfo;
function outAddress(address) {
    return address_1.toChecksumAddress(address);
}
exports.outAddress = outAddress;
function outAddresses(addresses) {
    return (addresses || []).map(outAddress);
}
exports.outAddresses = outAddresses;
function outBlock(block) {
    var result = {};
    if (block) {
        Object.keys(block).forEach(function (key) {
            switch (key) {
                case 'author':
                case 'miner':
                    result[key] = outAddress(block[key]);
                    break;
                case 'difficulty':
                case 'gasLimit':
                case 'gasUsed':
                case 'nonce':
                case 'number':
                case 'totalDifficulty':
                    result[key] = outNumber(block[key]);
                    break;
                case 'timestamp':
                    result[key] = outDate(block[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = block[key];
            }
        });
    }
    return result;
}
exports.outBlock = outBlock;
function outBlockReceipts(receipts) {
    if (receipts) {
        return receipts.map(outReceipt);
    }
    return receipts;
}
exports.outBlockReceipts = outBlockReceipts;
function outChainStatus(status) {
    var result = {};
    if (status) {
        Object.keys(status).forEach(function (key) {
            switch (key) {
                case 'blockGap':
                    result[key] = status[key]
                        ? status[key].map(outNumber)
                        : undefined;
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = status[key];
            }
        });
    }
    return result;
}
exports.outChainStatus = outChainStatus;
function outDate(date) {
    if (date instanceof Date && typeof date.toISOString === 'function') {
        return date;
    }
    try {
        if (typeof date === 'string' && new Date(date).toISOString() === date) {
            return new Date(date);
        }
    }
    catch (error) {
        /* Do nothing */
    }
    return new Date(outNumber(date).toNumber() * 1000);
}
exports.outDate = outDate;
function outHistogram(histogram) {
    var result = {};
    if (histogram) {
        Object.keys(histogram).forEach(function (key) {
            switch (key) {
                case 'bucketBounds':
                case 'counts':
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    result[key] = histogram[key].map(outNumber);
                    break;
            }
        });
    }
    return result;
}
exports.outHistogram = outHistogram;
function outLog(log) {
    var result = {};
    Object.keys(log).forEach(function (key) {
        switch (key) {
            case 'blockNumber':
            case 'logIndex':
            case 'transactionIndex':
                result[key] = outNumber(log[key]);
                break;
            case 'address':
                result[key] = outAddress(log[key]);
                break;
            default:
                // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                result[key] = log[key];
        }
    });
    return result;
}
exports.outLog = outLog;
function outHwAccountInfo(infos) {
    return Object.keys(infos).reduce(function (ret, _address) {
        var address = outAddress(_address);
        ret[address] = infos[_address];
        return ret;
    }, {});
}
exports.outHwAccountInfo = outHwAccountInfo;
function outNodeKind(info) {
    return info;
}
exports.outNodeKind = outNodeKind;
function outNumber(n) {
    return new bignumber_js_1.default(n || 0);
}
exports.outNumber = outNumber;
function outPeer(peer) {
    var protocols = Object.keys(peer.protocols).reduce(function (obj, key) {
        if (peer.protocols[key]) {
            // @ts-ignore
            obj[key] = Object.assign({}, peer.protocols[key], {
                difficulty: outNumber(
                // @ts-ignore "Object is possibly 'undefined'." No it's not.
                peer.protocols[key].difficulty)
            });
        }
        return obj;
    }, {});
    return {
        caps: peer.caps,
        id: peer.id,
        name: peer.name,
        network: peer.network,
        protocols: protocols
    };
}
exports.outPeer = outPeer;
function outPeers(peers) {
    return {
        active: outNumber(peers.active),
        connected: outNumber(peers.connected),
        max: outNumber(peers.max),
        peers: peers.peers.map(function (peer) { return outPeer(peer); })
    };
}
exports.outPeers = outPeers;
function outPrivateReceipt(receipt) {
    var result = {};
    if (receipt) {
        Object.keys(receipt).forEach(function (key) {
            switch (key) {
                case 'status':
                    result[key] = outNumber(receipt[key]);
                    break;
                case 'contractAddress':
                    result[key] = outAddress(receipt[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = receipt[key];
            }
        });
    }
    return result;
}
exports.outPrivateReceipt = outPrivateReceipt;
function outReceipt(receipt) {
    var result = {};
    if (receipt) {
        Object.keys(receipt).forEach(function (key) {
            switch (key) {
                case 'blockNumber':
                case 'cumulativeGasUsed':
                case 'gasUsed':
                case 'transactionIndex':
                    result[key] = outNumber(receipt[key]);
                    break;
                case 'contractAddress':
                    result[key] = outAddress(receipt[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = receipt[key];
            }
        });
    }
    return result;
}
exports.outReceipt = outReceipt;
function outSignerRequest(request) {
    var result = {};
    if (request) {
        Object.keys(request).forEach(function (key) {
            switch (key) {
                case 'id':
                    result[key] = outNumber(request[key]);
                    break;
                case 'payload':
                    result[key] = {};
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    result[key].decrypt = outSigningPayload(request[key].decrypt);
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    result[key].sign = outSigningPayload(request[key].sign);
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    result[key].signTransaction = outTransaction(
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    request[key].signTransaction);
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    result[key].sendTransaction = outTransaction(
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    request[key].sendTransaction);
                    break;
                case 'origin':
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    var type = Object.keys(result[key])[0];
                    // @ts-ignore "Object is possibly 'undefined'." No it's not.
                    var details = result[key][type];
                    request[key] = { type: type, details: details };
                    break;
            }
        });
    }
    return result;
}
exports.outSignerRequest = outSignerRequest;
function outSyncing(syncing) {
    var result = false;
    if (syncing && syncing !== 'false') {
        result = {};
        Object.keys(syncing).forEach(function (key) {
            switch (key) {
                case 'currentBlock':
                case 'highestBlock':
                case 'startingBlock':
                case 'warpChunksAmount':
                case 'warpChunksProcessed':
                    result[key] = outNumber(syncing[key]);
                    break;
                case 'blockGap':
                    result[key] = syncing[key]
                        ? syncing[key].map(outNumber)
                        : undefined;
                    break;
            }
        });
    }
    return result;
}
exports.outSyncing = outSyncing;
function outTransactionCondition(condition) {
    var result = null;
    if (condition) {
        result = {};
        if (condition.block) {
            result.block = outNumber(condition.block);
        }
        else if (condition.time) {
            result.time = outDate(condition.time);
        }
    }
    return result;
}
exports.outTransactionCondition = outTransactionCondition;
function outTransaction(tx) {
    var result = {};
    if (tx) {
        Object.keys(tx).forEach(function (key) {
            switch (key) {
                case 'blockNumber':
                case 'gasPrice':
                case 'gas':
                case 'nonce':
                case 'transactionIndex':
                case 'value':
                    result[key] = outNumber(tx[key]);
                    break;
                case 'condition':
                    result[key] = outTransactionCondition(tx[key]);
                    break;
                case 'creates':
                case 'from':
                case 'to':
                    result[key] = outAddress(tx[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = tx[key];
            }
        });
    }
    return result;
}
exports.outTransaction = outTransaction;
function outSigningPayload(payload) {
    var result = {};
    if (payload) {
        Object.keys(payload).forEach(function (key) {
            switch (key) {
                case 'address':
                    result[key] = outAddress(payload[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = payload[key];
            }
        });
    }
    return payload;
}
exports.outSigningPayload = outSigningPayload;
function outTrace(trace) {
    var result = {};
    if (trace) {
        Object.keys(trace).forEach(function (key) {
            switch (key) {
                case 'subtraces':
                case 'transactionPosition':
                case 'blockNumber':
                    result[key] = outNumber(trace[key]);
                    break;
                default:
                    // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                    result[key] = trace[key];
            }
        });
        if (trace.action) {
            result.action = {};
            Object.keys(trace.action).forEach(function (key) {
                switch (key) {
                    case 'gas':
                    case 'value':
                    case 'balance':
                        // @ts-ignore "Object is possibly 'undefined'." No it's not.
                        result.action[key] = outNumber(trace.action[key]);
                        break;
                    case 'from':
                    case 'to':
                    case 'address':
                    case 'refundAddress':
                        // @ts-ignore "Object is possibly 'undefined'." No it's not.
                        result.action[key] = outAddress(trace.action[key]);
                        break;
                    default:
                        // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                        result.action[key] = trace.action[key];
                }
            });
        }
        if (trace.result) {
            result.result = {};
            Object.keys(trace.result).forEach(function (key) {
                switch (key) {
                    case 'gasUsed':
                        // @ts-ignore "Object is possibly 'undefined'." No it's not.
                        result.result[key] = outNumber(trace.result[key]);
                        break;
                    case 'address':
                        // @ts-ignore "Object is possibly 'undefined'." No it's not.
                        result.action[key] = outAddress(trace.action[key]);
                        break;
                    default:
                        // @ts-ignore Here, we explicitly pass down extra keys, if they exist
                        result.result[key] = trace.result[key];
                }
            });
        }
        if (trace.traceAddress) {
            result.traceAddress = [];
            trace.traceAddress.forEach(function (address, index) {
                // @ts-ignore "Object is possibly 'undefined'." No it's not.
                result.traceAddress[index] = outNumber(address);
            });
        }
    }
    return result;
}
exports.outTrace = outTrace;
function outTraces(traces) {
    if (traces) {
        return traces.map(outTrace);
    }
    return traces;
}
exports.outTraces = outTraces;
function outTraceReplay(trace) {
    var result = {};
    if (trace) {
        Object.keys(trace).forEach(function (key) {
            switch (key) {
                case 'trace':
                    result[key] = outTraces(trace[key]);
                    break;
            }
        });
    }
    return result;
}
exports.outTraceReplay = outTraceReplay;
function outVaultMeta(meta) {
    if (types_1.isString(meta)) {
        try {
            var obj = JSON.parse(meta);
            return obj;
        }
        catch (error) {
            return {};
        }
    }
    return meta || {};
}
exports.outVaultMeta = outVaultMeta;
