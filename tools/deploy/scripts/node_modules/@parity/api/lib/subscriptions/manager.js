"use strict";
// Copyright 2015-2018 Parity Technologies (UK) Ltd.
// This file is part of Parity.
// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.
var isError = require('../util/types').isError;
var Eth = require('./eth');
var Logging = require('./logging');
var Personal = require('./personal');
var Signer = require('./signer');
var events = {
    'logging': { module: 'logging' },
    'eth_blockNumber': { module: 'eth' },
    'parity_accountsInfo': { module: 'personal' },
    'parity_allAccountsInfo': { module: 'personal' },
    'parity_defaultAccount': { module: 'personal' },
    'parity_postTransaction': { module: 'signer' },
    'eth_accounts': { module: 'personal' },
    'signer_requestsToConfirm': { module: 'signer' }
};
var Manager = /** @class */ (function () {
    function Manager(api) {
        var _this = this;
        this._api = api;
        this.subscriptions = [];
        this.values = {};
        Object.keys(events).forEach(function (subscriptionName) {
            _this.values[subscriptionName] = {
                error: null,
                data: null
            };
        });
        // in the case of a pubsub compliant, don't use the engines
        if (this._api.isPubSub) {
            return;
        }
        this._updateSubscriptions = this._updateSubscriptions.bind(this);
        this._logging = new Logging(this._updateSubscriptions);
        this._eth = new Eth(this._updateSubscriptions, api);
        this._personal = new Personal(this._updateSubscriptions, api, this);
        this._signer = new Signer(this._updateSubscriptions, api, this);
    }
    Manager.prototype._validateType = function (subscriptionName) {
        var subscription = events[subscriptionName];
        if (!subscription) {
            return new Error(subscriptionName + " is not a valid interface, subscribe using one of " + Object.keys(events).join(', '));
        }
        return subscription;
    };
    Manager.prototype.subscribe = function (subscriptionName, callback, autoRemove) {
        var _this = this;
        if (autoRemove === void 0) { autoRemove = false; }
        return new Promise(function (resolve, reject) {
            var subscription = _this._validateType(subscriptionName);
            if (isError(subscription)) {
                reject(subscription);
                return;
            }
            // use normal pub-sub as available
            if (_this._api.isPubSub) {
                try {
                    var _a = subscriptionName.split('_'), fnSection = _a[0], fnName = _a[1];
                    resolve(_this._api.pubsub[fnSection][fnName](callback));
                }
                catch (error) {
                    console.error('Unable to find subscriptionName', subscriptionName);
                    reject(error);
                }
                return;
            }
            var subscriptionId = _this.subscriptions.length;
            var _b = _this.values[subscriptionName], error = _b.error, data = _b.data;
            var engine = _this["_" + subscription.module];
            _this.subscriptions[subscriptionId] = {
                name: subscriptionName,
                id: subscriptionId,
                autoRemove: autoRemove,
                callback: callback
            };
            if (!engine.isStarted) {
                engine.start();
            }
            else if (error !== null || data !== null) {
                _this._sendData(subscriptionId, error, data);
            }
            resolve(subscriptionId);
        });
    };
    Manager.prototype.unsubscribe = function (subscriptionId) {
        var _this = this;
        if (this._api.isPubSub) {
            return this._api.pubsub.unsubscribe(subscriptionId);
        }
        return new Promise(function (resolve, reject) {
            if (!_this.subscriptions[subscriptionId]) {
                reject(new Error("Cannot find subscription " + subscriptionId));
                return;
            }
            delete _this.subscriptions[subscriptionId];
            resolve();
        });
    };
    Manager.prototype._sendData = function (subscriptionId, error, data) {
        var _a = this.subscriptions[subscriptionId], autoRemove = _a.autoRemove, callback = _a.callback;
        var result = true;
        try {
            result = callback(error, data);
        }
        catch (error) {
            console.error("Unable to update callback for subscriptionId " + subscriptionId, error);
        }
        if (autoRemove && result && typeof result === 'boolean') {
            this.unsubscribe(subscriptionId);
        }
    };
    Manager.prototype._updateSubscriptions = function (subscriptionName, error, data) {
        var _this = this;
        var subscriptions = this.subscriptions
            .filter(function (subscription) { return subscription.name === subscriptionName; });
        this.values[subscriptionName] = { error: error, data: data };
        subscriptions
            .forEach(function (subscription) {
            _this._sendData(subscription.id, error, data);
        });
    };
    return Manager;
}());
Manager.events = events;
module.exports = Manager;
