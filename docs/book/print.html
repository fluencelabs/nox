<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fluence book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li><a href="introduction/motivation.html"><strong aria-hidden="true">1.2.</strong> Motivation</a></li><li><a href="introduction/incentive_model.html"><strong aria-hidden="true">1.3.</strong> Incentive model</a></li></ol></li><li><a href="quickstart/index.html"><strong aria-hidden="true">2.</strong> Quick start</a></li><li><ol class="section"><li><a href="quickstart/rust.html"><strong aria-hidden="true">2.1.</strong> Developing the backend app</a></li><li><a href="quickstart/publish.html"><strong aria-hidden="true">2.2.</strong> Publishing your app</a></li><li><a href="quickstart/web.html"><strong aria-hidden="true">2.3.</strong> Developing the web app</a></li><li><a href="quickstart/wrappingup.html"><strong aria-hidden="true">2.4.</strong> Wrapping up</a></li></ol></li><li><a href="backend/index.html"><strong aria-hidden="true">3.</strong> Backend guide</a></li><li><ol class="section"><li><a href="backend/app_conventions.html"><strong aria-hidden="true">3.1.</strong> Backend app conventions</a></li><li><a href="backend/sdk_overview.html"><strong aria-hidden="true">3.2.</strong> Fluence backend SDK overview</a></li><li><a href="backend/app_debugging.html"><strong aria-hidden="true">3.3.</strong> Backend app debugging</a></li><li><a href="backend/examples.html"><strong aria-hidden="true">3.4.</strong> Examples</a></li><li><a href="backend/best_practices.html"><strong aria-hidden="true">3.5.</strong> Best practices</a></li></ol></li><li><a href="roles/miner.html"><strong aria-hidden="true">4.</strong> Miner guide</a></li><li><a href="tools/index.html"><strong aria-hidden="true">5.</strong> Tools and SDKs</a></li><li><ol class="section"><li><a href="tools/cli_README.html"><strong aria-hidden="true">5.1.</strong> CLI</a></li><li><a href="tools/rust_README.html"><strong aria-hidden="true">5.2.</strong> Rust SDK</a></li><li><a href="tools/js_README.html"><strong aria-hidden="true">5.3.</strong> JS SDK</a></li></ol></li><li><a href="project.html"><strong aria-hidden="true">6.</strong> Project status</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Fluence book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#what-is-fluence" id="what-is-fluence"><h2>What is Fluence?</h2></a>
<p>Fluence is an efficient trustless computation platform that allows to achieve few seconds request processing latency and cost efficiency similar to traditional cloud computing. To execute computations, Fluence uses a WebAssembly virtual machine, which allows to deploy into the decentralized environment applications written in multiple programming languages.</p>
<a class="header" href="#what-can-be-built-with-fluence" id="what-can-be-built-with-fluence"><h2>What can be built with Fluence?</h2></a>
<p>Fluence can be used as a general purpose backend engine for decentralized applications. Because of its cost efficiency, developers generally do not have to worry much about low-level code optimization. Existing software packages can be ported to Fluence as is, once they are compiled into WebAssembly.</p>
<a class="header" href="#decentralized-databases" id="decentralized-databases"><h4>Decentralized databases</h4></a>
<p>As an <a href="https://github.com/fluencelabs/fun/tree/master/llamadb">example</a>, we have ported an existing toy SQL database <a href="https://github.com/nukep/llamadb">LlamaDB</a> to run in the decentralized environment by making just a few modifications and compiling it into WebAssembly.</p>
<p>We expect it should not be extremely difficult to port an existing database such as <a href="https://www.sqlite.org/index.html">SQLite</a> or <a href="https://github.com/facebook/rocksdb">RocksDB</a> to Fluence. Deployed, this database could serve frontends of user-facing decentralized applications.</p>
<p>This, coupled with decentralized storages such as IPFS or Swarm could enable fully decentralized applications. Such applications would use a decentralized storage to store static data, and a decentralized database running on top of Fluence – to serve dynamic client requests.</p>
<a class="header" href="#gambling-applications" id="gambling-applications"><h4>Gambling applications</h4></a>
<p>Simple dice games or roulette can be ported to Fluence fairly easily. However, at the current moment Fluence is not able to run by itself <a href="https://en.wikipedia.org/wiki/Perfect_information">imperfect information games</a> such as Texas Holdem poker or Guess the Number. The reason is that full game state can be read by nodes running the backend, and Fluence does not have privacy-preserving computations built in into its SDK.</p>
<p>We expect, however, that approaches such as <a href="https://ethereum.stackexchange.com/questions/376/what-are-effective-and-secure-ways-of-shuffling-a-deck-of-cards-in-a-contract/758">decentralized card deck shuffling</a> can be employed to port certain imperfect information games to the Fluence network. In the meanwhile we have prepared a <em><a href="https://github.com/fluencelabs/fun/tree/master/guessing-game">broken implementation</a></em> of Guess the Number game ;)</p>
<a class="header" href="#games" id="games"><h4>Games</h4></a>
<p>Perfect information games can be easily built on top of Fluence. Think of chess, Go, rock–paper–scissors, games similar to Dungeons and Dragons, or roll-and-move board games. We have prepared a <a href="https://github.com/fluencelabs/fun/tree/master/tic-tac-toe">tic-tac-toe</a> example to play with. Collectible decentralized applications can be launched on Fluence as well.</p>
<a class="header" href="#how-does-fluence-work" id="how-does-fluence-work"><h2>How does Fluence work?</h2></a>
<p>In order to reach low latency and high throughput, Fluence splits network nodes into two layers: the <em>real-time processing layer</em> and the <em>batch validation layer</em>.</p>
<p>The real-time processing layer is able to promptly serve client requests, but provides only moderate security guarantees that returned responses are correct. Later, the batch validation layer additionally verifies returned responses, and if it is found that some of the responses were incorrect, offending real-time nodes lose their deposits.</p>
<p>In this section we provide brief Fluence overview and discuss reasons to have delayed verification. We also consider Fluence basic incentive model.</p>
<a class="header" href="#overview" id="overview"><h1>Overview</h1></a>
<p>The Fluence network consists of nodes performing computations in response to transactions sent by external clients. Algorithms specifying those computations are expressed in the WebAssembly bytecode; consequently, every node willing to participate in the network has to run a WebAssembly virtual machine.</p>
<p>Independent developers are expected to implement a backend package handling client transactions in a high-level language such as C/C++, Rust, or TypeScript, compile it into one or more WebAssembly modules, and then deploy those modules to the Fluence network. The network then takes care of spinning up the nodes that run the deployed backend package, interacting with clients, and making sure that client transactions are processed correctly.</p>
<a class="header" href="#architecture" id="architecture"><h2>Architecture</h2></a>
<p>Two major layers exist in the Fluence network: the real-time processing layer and the batch validation layer. The former is responsible for direct interaction with clients; the latter, for computation verification. In other words, real-time processing is the speed layer and batch validation is the security layer. The network also relies on Ethereum (as a secure metadata storage and dispute resolution layer) and Swarm (as a data availability layer)</p>
<div style="text-align:center">
<kbd>
<img src="../images/architecture_overview.png" width="666px"/>
</kbd>
<br><br><br>
</div>
<a class="header" href="#components" id="components"><h2>Components</h2></a>
<a class="header" href="#real-time-processing-layer" id="real-time-processing-layer"><h3>Real-time processing layer</h3></a>
<p>The real-time processing layer consists of multiple real-time clusters, which are stateful and keep locally the state required to serve client requests. Each cluster is formed by a few real-time worker nodes that are responsible for running particular backend packages and storing related state data. Workers in real-time clusters use Tendermint to reach BFT consensus and an interim metadata storage (built on top of a DHT such as Kademlia) to temporarily store consensus metadata before it is compacted and uploaded to the Ethereum blockchain.</p>
<div style="text-align:center">
<kbd>
<img src="../images/rt_overview.png" width="736px"/>
</kbd>
<br><br><br>
</div>
<p>To deploy a backend package to the Fluence network, the developer first has to allocate a cluster to run the package. Once the package is deployed, those functions that are exposed as external can be invoked by client transactions. If the package is no longer needed, the developer is able to terminate the cluster.</p>
<p>Developers possess significant control over real-time clusters: they are able to specify the desired cluster size and how much memory each node in the cluster should allocate to store the state. If one of the workers in the cluster is struggling, the developer who has allocated the cluster can replace this worker with a more performant one.</p>
<p>Real-time clusters are able to promptly respond to client requests, but those responses carry only moderate security guarantees when a significant fraction of network nodes are malicious. Because real-time clusters are formed by just a few worker nodes, they can tolerate only few malicious nodes, which leaves a non-trivial chance that a real-time cluster might be completely dominated by attackers. Therefore, an additional level of verification is required for computations performed by real-time clusters.</p>
<a class="header" href="#batch-validation-layer" id="batch-validation-layer"><h3>Batch validation layer</h3></a>
<p>To keep real-time clusters in check, the batch validation layer separately verifies all performed computations. This layer is composed of independent batch validators, which are stateless and have to download the required data before performing verification. In order to support this, every real-time cluster is required to upload the history of received transactions and performed state transitions to Swarm. Because Tendermint organizes transactions into blocks that each carry the hash of the state obtained after the previous block execution, real-time clusters upload transactions to Swarm in blocks as well.</p>
<p>Later on, batch validators replay fragments of transaction history, which are composed of one or more blocks, and challenge state transitions that they have deemed incorrect through the dispute resolution layer. If one of the state transitions is not correct, it takes only a single honest validator to challenge this and penalize the real-time cluster that performed the transition.</p>
<div style="text-align:center">
<kbd>
<img src="../images/validation_overview.png" width="651px"/>
</kbd>
<br><br><br>
</div>
<p>Developers do not have any control over batch validators beyond deciding how much budget is carved out for batch validation – i.e., how many batch validations should happen for the fragment of transaction history once it is uploaded to Swarm. Furthermore, the batch validator that verifies any specific history fragment is chosen randomly out of all batch validators in the network in order to prevent possible cartels.</p>
<p>Batch validators compact the transaction history and reduce Swarm space usage by uploading intermediate state snapshots to Swarm. Once a transaction history fragment has been verified a sufficient number of times, it is dropped, leaving only the corresponding snapshot.</p>
<div style="text-align:center">
<kbd>
<img src="../images/validation_state.png" width="705px"/>
</kbd>
<br><br><br>
</div>
<a class="header" href="#dispute-resolution-layer" id="dispute-resolution-layer"><h3>Dispute resolution layer</h3></a>
<p>We have already mentioned that batch validators are able to dispute state transitions. This ability is not exclusive to batch validators: a real-time worker can submit a dispute if it disagrees with another real-time worker on how the state should be updated. However, such disputes normally arise only between workers that belong to the same cluster – other real-time workers simply do not carry the required state.</p>
<p>No matter which node has submitted the dispute, it is resolved with the aid of an external authority. The Fluence network uses a specially developed Ethereum smart contract named Arbiter as this authority. Because Ethereum is computationally bounded and thus unable to repeat the entire computation to verify state transitions, a verification game mechanism is used to find the first WebAssembly instruction that produced the diverging states. Only this instruction with the relevant portion of the state is then submitted to the Arbiter contract, which then makes its final decision as to which node performed the incorrect state transition.</p>
<p>Every node in the network is required to put down a significant security deposit before performing computations. If it is found that a node has behaved incorrectly, its deposit is slashed. Assuming that potential adversaries are financially restricted, this reduces the number of cases where a client might receive an incorrect response.</p>
<a class="header" href="#data-availability-layer" id="data-availability-layer"><h3>Data availability layer</h3></a>
<p>The Swarm receipts mechanism is used to make sure that the fragments of transaction history uploaded by the real-time clusters do not disappear before the batch validators replay and verify them. The Swarm receipt is a confirmation from the Swarm node that it is responsible for the specific uploaded data. If the Swarm node is not able to return the data when requested, its deposit is slashed, which prevents Swarm from losing potentially incriminating data.</p>
<a class="header" href="#secure-metadata-storage" id="secure-metadata-storage"><h3>Secure metadata storage</h3></a>
<p>Deposits placed by Fluence network nodes, Swarm receipts issued for transaction history fragments, and metadata entries related to the batch validation and real- time cluster compositions are stored in the Ethereum blockchain. For the sake of simplicity in this paper, we will assume that the Arbiter contract holds this data in addition to its dispute resolution responsibilities.</p>
<a class="header" href="#motivation" id="motivation"><h1>Motivation</h1></a>
<p>To understand the reason behind having two noticeably different layers, we need to recall their properties. Real-time workers are stateful, which considerably improves response latencies because they do not have to download the required state data to perform computations.
As an example, assume that we are building a decentralized SQL database that should support an indexed access to data. Complex queries such as the one listed below often require traversal of multiple indices, which are often implemented as B-trees.</p>
<pre><code class="language-sql">SELECT
    DATE(ts) AS date,
    AVG(gas_price * gas_used) AS tx_cost
FROM transactions tx WHERE
    tx.to IN (SELECT address
              FROM contracts
              WHERE name = ’CryptoDolphins’) 
GROUP BY DATE(ts)
</code></pre>
<p><em>Example query to blockchain data.</em></p>
<p>To traverse a B-tree, we need to sequentially fetch its nodes that satisfy the query conditions. It is not possible to retrieve the required B-tree nodes all at once because the next node to fetch can be determined only by matching the parent B-tree node against the query. If an index is stored externally in a decentralized storage such as IPFS or Swarm, this means that multiple network roundtrips must be performed between the machine performing the computations and the data storage, which significantly increases latency.</p>
<p>Other algorithms, especially those requiring irregular access to data, could benefit from storing their data locally as well. However, data locality significantly increases the economic barrier to joining a real-time cluster because a worker willing to participate in the cluster has to download the current state first. Consequently, this motivates workers to remain in the cluster and thus cluster compositions do not change much over time.</p>
<p>This means that malicious real-time workers in the cluster might form a cartel to produce incorrect results. Without batch validation, every node in the real-time cluster knows it will be verified only by its peers, which are known in advance because clusters are tightly connected. Consequently, malicious nodes can, for example, exploit the following strategy: use a special handshake to recognize other malicious nodes in the cluster and start producing incorrect results if they account for at least \(\frac{2}{3}\) of the total number of nodes (so they can reach BFT consensus without talking to the rest of the cluster); otherwise, work honestly. This strategy is virtually impossible to catch without external verification.</p>
<p>Furthermore, because real-time clusters are supposed to be small enough to be cost-efficient, the probability that malicious nodes will take over a cluster is significant. For example, for a network where 10% of all nodes are malicious, a real-time cluster that consists of 7 workers independently sampled from the network has approximately a 1.8 · 10<sup>−4</sup> chance to have at least \(\frac{2}{3}\) malicious nodes.</p>
<p>To counteract this, the batch validation layer provides external verification. Nodes performing batch validation are chosen randomly, which means real-time nodes do not know beforehand which validator will be verifying them and thus cannot collude with the validator in advance.</p>
<p>Batch validation also decreases the probability that an intentional mistake made by a real-time cluster will never get noticed. Assume that in the same network where 10% of all nodes are malicious, we spun a real-time cluster of 4 workers and allocated a budget for 3 batch validations.</p>
<p>In this setup, a mistake can go unnoticed only if malicious actors comprise at least \(\frac{2}{3}\) of the realtime workers and all of the batch validators that verified the transaction history. The chance of this happening is ≈ 3.7 · 10<sup>−6</sup>, which is two orders of magnitude less than in the case where the entire budget was spent on the real-time cluster only.</p>
<p>We also expect that in the presence of batch validators, the fraction of malicious nodes in the network will drop significantly below 10%, because every time a malicious action is caught, the node that performed it loses its deposit and thus leaves the network.</p>
<a class="header" href="#incentive-model" id="incentive-model"><h1>Incentive model</h1></a>
<p>Fluence uses a concept similar to Ethereum gas to track computational efforts. With few exceptions, every WebAssembly instruction has a predefined associated cost, which is named fuel to avoid confusion with Ethereum gas. The fuel required to perform a computation is roughly proportional to the total sum of fuel amounts assigned to instructions in the computation execution trace.</p>
<p>When it comes to storage usage accounting, Fluence rules differ significantly from Ethereum. Ethereum instructions for interacting with persistent storage require the client to pay a one-time fee – which is significant – to compensate for a certain amount of future expenses that will be incurred in storing the information. For example, <code>SSTORE</code> (the instruction that is used to save a word to the persistent storage) costs 20,000 gas, which is a few orders of magnitude more than the cost of basic instructions such as <code>POP</code>, <code>ADD</code>, or <code>MUL</code>, which require 2–5 gas.</p>
<p>While this approach has been working fairly well for Ethereum, we think that adapting it to the Fluence network – the aim of which is achieving cost-efficiency comparable to traditional clouds – is problematic. In conventional backend software, it is common to update an on-disk or in-memory state without worrying that the performed update costs considerably more than other operations. In order to easily port existing software to Fluence, we need to provide developers a method that does not require them to fundamentally modify the code being ported.</p>
<p>Another reason to reconsider storage accounting is that execution of WebAssembly instructions and provision of data storage are quite different. If we say that network nodes are compensated for the performed work, then the total difficulty of processed instructions indeed defines an amount of the work performed. However, allocating a megabyte of storage is not <em>work</em> – it is <em>power</em>. Only after a node has kept a megabyte of data in storage for a certain time can we estimate how much work it has performed: <em>work</em> = <em>power</em> · <em>time</em>.</p>
<p>When a client pays a one-time upfront fee to upload their data, there is no way for the network node responsible for its storage to know how long the data will be stored. No matter how large the upfront fee is, it is possible that expenses required to store the data will exceed this fee, leaving the financial burden on the node. This means that a different storage accounting approach must be developed for the Fluence network, which we propose and discuss below.</p>
<p><strong>Rewards accounting.</strong> To counteract the aforementioned issues, various storage rent fees were proposed for Ethereum, including requiring clients to pay a fee to renew their storage every time they issue a transaction. However, to bring the developer experience as close as possible to traditional backend software, in the Fluence network, the developer is the only party finally responsible for compensating network nodes.</p>
<p>Fluence nodes are compensated for the computational difficulty of executed WebAssembly instructions and for the storage space allocated for a specific period of time. Because different hardware might need different time to execute the same program, computational difficulty is used as a sub- stitution for time. In other words, once a block of client transactions is processed and the fuel <em>φ</em> required to process it is counted, this fuel is transformed into the standard time <em>t</em><sub>std</sub> by multiplying it by the network-wide scaling constant <em>c</em><sub>time/fuel</sub>:</p>
<p><center>
<em>t</em><sub>std</sub> = <em>c</em><sub>time/fuel</sub> · <em>φ</em>
<br><br>
</center></p>
<p>To estimate the total node reward <em>υ</em>, two more scaling constants are introduced: <em>c</em><sub>υ/fuel</sub> converts spent units of fuel into the network currency; <em>c</em><sub>υ/spacetime</sub> does the same with the unit of storage space allocated for the unit of time. does the same with storage space per time. Assuming that the size of the allocated storage space is denoted by <em>ω</em>, the total node reward is computed as:</p>
<p><center>
<em>υ</em> = <em>c</em><sub>υ/fuel</sub> · <em>φ</em> + <em>c</em><sub>υ/spacetime</sub> · <em>ω</em> · <em>t</em><sub>std</sub>
<br><br>
</center></p>
<p>It should be noted that contrary to the system used by Ethereum where a client is able to choose a different gas price for every transaction, the scaling constants <em>c</em><sub>time/fuel</sub>, <em>c</em><sub>υ/fuel</sub>, and <em>c</em><sub>υ/spacetime</sub> are fixed for the entire Fluence network. One reason for this design is that batch validators are selected randomly and are not able to choose the computations they are going to verify.</p>
<p>By allowing clients or developers to choose their compensation level, batch validators might be forced to perform complex computations for an unreasonably low reward. To prevent this, scaling constants are periodically updated, similar to how mining difficulty changes in Ethereum. If there is not enough supply, the network-wide compensation level increases; conversely, if there is not enough demand, the compensation level drops.</p>
<p><strong>Dummy transactions.</strong> Because time is counted only for performed computations, simply storing the state without processing transaction blocks does not ensure any compensation to real-time workers. Therefore, in cases where incoming client transactions are rare, it is possible that the block creation rate will be low and thus low-demand backends will spend lots of time storing the state between the blocks. This time will never be compensated; workers running such low-demand backends might spend far more resources to store the state than their total compensation will be.</p>
<p>To offset this, real-time workers are allowed to send dummy transactions to themselves; the fuel required to process such dummy transactions is accounted for in the same way as the fuel required to process client transactions. This way, even if the client transaction volume is low, real-time workers will be compensated proportionally to the (real-world) time they have been running a certain backend deployment.</p>
<p>Batch validators, however, are not affected by this issue because they do not have to wait for incoming transactions and new blocks. A batch validator replays a fragment of transaction history at the maximum rate it is able to perform; once it completes the processing of the fragment, it moves to the next fragment. Additionally, for the same amount of work (which is defined by used fuel), real-time workers and batch validators are compensated evenly, which makes both options equally attractive to miners. Therefore, no special mechanism to recompense batch validators exists in the Fluence network.</p>
<p>Because different hardware can process transactions at different rates, it might happen that a very fast real-time cluster will be able to produce and process dummy transactions so fast that the compensation from the developer will become unexpectedly high. To mitigate this, in addition to being able to set the size of the storage space <em>ω</em>, developers have the ability to set the maximum fuel amount <em>φ</em><sub>max</sub> that real-time workers are allowed to spend per unit of time.</p>
<p>This allows a developer to budget how much will be spent on computations performed by the Fluence network in the next day, week, or month. Additionally, it lets real-time workers plan how much capacity they should allocate for transaction processing performed by the backend deployed by that developer.</p>
<p>We should note that it is possible for ill-disposed real-time workers to process only self-created dummy transactions – and none sent by clients. While we do not discuss a detailed mechanism to combat such behavior in this paper, we should note that a developer monitoring the use of the deployed backend will be able to notice a drop in the ratio between client and dummy transactions. In this case, the developer can either replace misbehaving real-time workers with other network nodes, or reduce the amount of fuel <em>φ</em><sub>max</sub> that the real-time cluster is allowed to spend per unit of time.</p>
<p><strong>Client billing.</strong> As we have previously mentioned, developers are exclusively responsible for paying out rewards to the Fluence network nodes. Because miners’ compensation is proportional to used fuel and allocated storage space, developers are directly incentivized to write efficient backends.</p>
<p>Generally, clients are not responsible for making any payments to network nodes. Nevertheless, different external monetization schemes are possible for reimbursing developers. The Fluence network does not prescribe an exact monetization scheme; however, it might provide some of the most common schemes through extension packages.</p>
<p>For example, one developer might allow only those clients from a whitelist to interact with the deployed backend, charging a flat rate to add a client to that whitelist; another developer might charge clients a fixed fee per each submitted transaction. It might also be possible for clients to pay no explicit fee while the developer uses their personal funds to cover the miners’ expenses.</p>
<a class="header" href="#quickstart" id="quickstart"><h1>Quickstart</h1></a>
<p>This document will guide you through three main steps of development with Fluence.</p>
<p>You will develop a traditional two-tiered web application with a backend written in Rust, and a frontend built with JavaScript. Unlike traditional two-tiered architecture, however, your backend will be decentralized and running on top of the Fluence network, not requiring a dedicated server machine.</p>
<p>We will show you how to use Fluence Rust SDK to develop a backend in Rust, and compile it to WebAssembly. Then, to deploy your backend to the Fluence network, you will publish it to the Fluence smart contract. And finally, build a frontend integrated with your decentralized backend.</p>
<p>If you experience any problems with this guide, or a desire to discuss Fluence with the team, feel free to join our <a href="https://discordapp.com/invite/AjfbDKQ">Discord</a>.</p>
<a class="header" href="#developing-the-backend-app" id="developing-the-backend-app"><h1>Developing the backend app</h1></a>
<p>Fluence runs Webassembly programs, so it's possible to build a Fluence backend in any program language that targets Wasm. In this guide, we will use Rust as a language of choice.</p>
<p>First you will build a simple hello-world backend in Rust, adapt it to be used with Fluence, and compile to Webassembly.</p>
<a class="header" href="#setting-up-rust" id="setting-up-rust"><h2>Setting up Rust</h2></a>
<p>Let's get some Rust.</p>
<p>Install rust compiler and it's tools:</p>
<pre><code class="language-bash"># install Rust compiler and other tools to `~/.cargo/bin`
~ $ curl https://sh.rustup.rs -sSf | sh -s -- -y
info: downloading installer
...
Rust is installed now. Great!
To configure your current shell run source $HOME/.cargo/env
</code></pre>
<p>Let's listen to the installer and configure your current shell:</p>
<pre><code class="language-bash">~ $ source $HOME/.cargo/env
&lt;no output&gt;
</code></pre>
<p>Fluence Rust SDK <a href="???">uses custom allocator (TODO: link)</a> for copying bytes to and from virtual machine internal memory, and that requires nightly toolchain. To install nightly toolchain, run:</p>
<pre><code class="language-bash">~ $ rustup toolchain install nightly
info: syncing channel updates ...
...
  nightly-&lt;arch&gt; installed - rustc 1.34.0-nightly (57d7cfc3c 2019-02-11)
</code></pre>
<p>To check nightly toolchain was installed succesfully:</p>
<pre><code class="language-bash">~ $ rustup toolchain list | grep nightly
# output should contain nighly toolchain
...
nightly-&lt;arch&gt;
</code></pre>
<p>Also, to be able to compile Rust to WebAssembly, we need to add wasm32 compilation target. Just run the following:</p>
<pre><code class="language-bash"># install target for WebAssembly
~ $ rustup target add wasm32-unknown-unknown --toolchain nightly
info: downloading component 'rust-std' for 'wasm32-unknown-unknown'
info: installing component 'rust-std' for 'wasm32-unknown-unknown'
</code></pre>
<p>To check that everything is set up correctly, let's compile some Rust code:</p>
<pre><code class="language-bash"># create test.rs with a simple program that returns number 1
~ $ echo &quot;fn main(){1;}&quot; &gt; test.rs

# compile it to wasm using rustc from nightly toolchain
~ $ rustup run nightly rustc --target=wasm32-unknown-unknown test.rs
&lt;no output&gt;

# check test.wasm was created
~ $ ls -lh test.wasm
-rwxr-xr-x  1 user  user   1.4M Feb 11 11:59 test.wasm
</code></pre>
<p>If everything looks similar, then it's time to create a Rust hello-world project!</p>
<a class="header" href="#creating-an-empty-rust-package" id="creating-an-empty-rust-package"><h2>Creating an empty Rust package</h2></a>
<p>First, let's create a new empty Rust package:</p>
<pre><code class="language-bash"># create empty Rust package
~ $ cargo +nightly new hello-world --edition 2018
Created binary (application) `hello-world` package

# go to the package directory
~ $ cd hello-world
~/hello-world $
</code></pre>
<p>More info on creating a new Rust project can be found in <a href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html">Rust docs</a>.</p>
<a class="header" href="#optional-creating-a-hello-world-rust-application" id="optional-creating-a-hello-world-rust-application"><h2>Optional: Creating a Hello World Rust application</h2></a>
<p>If you are familiar with Rust, feel free to <a href="#creating-a-fluence-hello-world-backend">skip</a> that section.</p>
<p>Let's write some code. Our backend should be able to receive a username from program arguments, and print greeting with the username in it.</p>
<p>Take a look at <code>src/main.rs</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat src/main.rs
</code></pre>
<p>You will see the following code. It's there by default:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>It almost does what we need, except for reading a username. So, open <code>src/main.rs</code> in your editor, delete all the code in there, and paste the following:</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}

fn main() {
    let name = env::args().nth(1).unwrap();
    println!(&quot;{}&quot;, greeting(name));
}
</code></pre></pre>
<p>What this code does:</p>
<ol>
<li>Defines a <code>greeting</code> function that takes a name, and returns a greeting message</li>
<li>Defines a <code>main</code> function that reads first program argument, passes it to <code>greeting</code>, and prints the result</li>
</ol>
<p>Let's now compile and run our example:</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly run myName
   Compiling hello-world v0.1.0 (/root/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/hello-world myName`
Hello, world! From user myName
</code></pre>
<hr />
<p><strong>WARNING:</strong> If you see the following error, you should install <a href="https://gcc.gnu.org/install/">gcc</a> and try <code>cargo +nightly run</code> again:</p>
<pre><code class="language-bash">Compiling hello-world v0.1.0 (/root/hello-world)
error: linker cc not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error
error: Could not compile hello-world.
</code></pre>
<hr />
<p>Now that we have a working hello world, it's time to adapt it to be used with Fluence.</p>
<a class="header" href="#creating-a-fluence-hello-world-backend" id="creating-a-fluence-hello-world-backend"><h2>Creating a Fluence Hello World backend</h2></a>
<p>For a backend to be compatible with Fluence network, it should <a href="quickstart/backend.html#wasm-program-conventions">follow a few conventions</a>, so Fluence knows how to call your code correctly. To reduce boilerplate and make it easier, we developed a Fluence Rust SDK. Let's see how to use it.</p>
<a class="header" href="#adding-fluence-as-a-dependency" id="adding-fluence-as-a-dependency"><h3>Adding Fluence as a dependency</h3></a>
<p>First you need to add it to <code>Cargo.toml</code> as a dependency. Let's take a look at <code>Cargo.toml</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat Cargo.toml
</code></pre>
<p>It should look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Now, open <code>Cargo.toml</code> in your editor, and add <code>fluence</code> to <code>dependencies</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#implementing-backend-greeting-logic" id="implementing-backend-greeting-logic"><h3>Implementing backend greeting logic</h3></a>
<p>Create &amp; open <code>~/hello-world/src/lib.rs</code> in your editor and paste the following code there:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
#}</code></pre></pre>
<p>This code imports Fluence SDK, and marks <code>greeting</code> function with <code>#[invocation_handler]</code>, so Fluence knows how to call it.</p>
<p>Function marked with <code>#[invocation_handler]</code> is called a <em>gateway function</em>. It is an entrypoint to your application, all transactions sent by users will be passed to that function, and it's result will be available to users. Gateway function can receive and return either <code>String</code> or <code>Vec&lt;u8&gt;</code>.</p>
<a class="header" href="#making-it-a-library" id="making-it-a-library"><h3>Making it a library</h3></a>
<p>For a gateway function to be exported and available for Fluence to call, backend should be compiled to WebAssembly as a library.</p>
<p>To make your backend a library, open <code>Cargo.toml</code> in your editor, and paste the following there:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[lib]
name = &quot;hello_world&quot;
path = &quot;src/lib.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#compiling-to-webassembly" id="compiling-to-webassembly"><h3>Compiling to WebAssembly</h3></a>
<p>Run the following code to build a <code>.wasm</code> file from your Rust code.</p>
<p>NOTE: Downloading and compiling dependencies might take a few minutes.</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly build --lib --target wasm32-unknown-unknown --release
    Updating crates.io index
    ...
    Finished release [optimized] target(s) in 1m 16s
</code></pre>
<p>If everything goes well, you should have a <code>.wasm</code> file deep in <code>target</code>. Let's check it:</p>
<pre><code class="language-bash">~/hello-world $ ls -lh target/wasm32-unknown-unknown/release/hello_world.wasm
-rwxr-xr-x  2 user  user  1.4M Feb 11 11:59 target/wasm32-unknown-unknown/release/hello_world.wasm
</code></pre>
<a class="header" href="#publishing-your-app" id="publishing-your-app"><h1>Publishing your app</h1></a>
<p>In Fluence network, app is deployed by uploading the Wasm code to Swarm, and publishing hash-address of the code to the Fluence smart contract.</p>
<p>It is possible to specify desired cluster size along with the hash-address. Cluster size sets the required number of real-time workers in the cluster hosting the app. Note that app would wait in the queue until there is enough free workers to create a cluster of the desired size.</p>
<a class="header" href="#connect-to-swarm-and-ethereum-rinkeby" id="connect-to-swarm-and-ethereum-rinkeby"><h2>Connect to Swarm and Ethereum Rinkeby</h2></a>
<p>To publish a backend app to Fluence network, you need to upload it to Swarm, and then send its location in Swarm to a Fluence smart contract on Ethereum Rinkeby testnet.</p>
<p>To make sure we're on the same page:</p>
<ul>
<li>Swarm is a decentralized file storage.</li>
<li>Ethereum Rinkeby testnet is one of the many Ethereum networks, but there's no real money in there, so it's safe and can be used for trying out something new.</li>
<li>Fluence smart contract is what rules the Fluence network and allows users to use it.</li>
</ul>
<p>To upload your code to Swarm, you need to have access to one of its nodes. The same with Ethereum, you will need a connection to any Ethereum node on Rinkeby testnet.</p>
<p><strong>We will use existing Ethereum &amp; Swarm nodes, but if you wish, you can <a href="quickstart/../roles/miner.html">use your own nodes</a> or any other.</strong></p>
<a class="header" href="#registering-an-ethereum-rinkeby-account" id="registering-an-ethereum-rinkeby-account"><h2>Registering an Ethereum Rinkeby account</h2></a>
<a class="header" href="#via-myetherwalletcom" id="via-myetherwalletcom"><h3>Via myetherwallet.com</h3></a>
<p>Go to <a href="https://vintage.myetherwallet.com/">MyEtherWallet.com</a>, then select any Rinkeby in the upper right, enter any password, and download the Keystore file.</p>
<a class="header" href="#top-up-account-with-funds" id="top-up-account-with-funds"><h3>Top up account with funds</h3></a>
<p>There are two main Rinkeby faucets. <a href="https://faucet.rinkeby.io/">This one</a> will give you up to 18 Ether, but it requires you to post an Ethereum address to a social network, <a href="http://rinkeby-faucet.com/">another one</a> gives you ETH right away, but just <code>0.001</code>  ether.</p>
<p><code>0.001</code> ether is enough for the sake of this tutorial, so you may want to go with the <a href="http://rinkeby-faucet.com/">easier one</a></p>
<a class="header" href="#installing-fluence-cli" id="installing-fluence-cli"><h2>Installing Fluence CLI</h2></a>
<p>Creating publish transactions manually is hard and error-prone, so we provide Fluence CLI to make this task easier.</p>
<p>You can download Fluence CLI from the <a href="https://github.com/fluencelabs/fluence/releases/">latest release</a></p>
<p>Or in terminal:</p>
<p><strong>Linux</strong></p>
<pre><code class="language-bash">~ $ curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.4/fluence-cli-0.1.4-linux-x64 -o fluence
</code></pre>
<p><strong>macOS</strong></p>
<pre><code class="language-bash">~ $ curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.4/fluence-cli-0.1.4-mac-x64 -o fluence

</code></pre>
<p>And finally don't forget to add permission to execute it:</p>
<pre><code class="language-bash">~ $ chmod +x ./fluence

# check CLI is working
~ $ ./fluence --version
Fluence CLI 0.1.4
</code></pre>
<p>If you see CLI version, proceed to the next step.</p>
<a class="header" href="#publishing-via-fluence-cli" id="publishing-via-fluence-cli"><h2>Publishing via Fluence CLI</h2></a>
<p>As was mentioned before, you will need a connection to Ethereum Rinkeby network, and a connection to Swarm network.</p>
<p>For your convenience, and to make this guide simple, we use addresses of existing Ethereum Rinkeby and Swarm nodes running in a cloud on Fluence nodes. <strong>However, this is a centralized way to connect to Ethereum Rinkeby and Swarm networks, and shouldn't be used in production or in a security-sensitive context.</strong> You may use <strong>any</strong> Rinkeby and Swarm nodes by providing their URIs within <code>--eth_url</code> and <code>--swarm_url</code> options (see below).</p>
<p>Also you will need a Rinkeby account with some money on it (you can <a href="https://faucet.rinkeby.io/">get money from faucet</a>) and it's private key. Private key can be either a hex string or a <a href="quickstart/../cli/README.html#keystore-json-file">JSON keystore file</a>.</p>
<p>Having all that, you're now ready to publish your app. Examples below will specify a cluster size of 4 nodes for your app. Adjust it to your needs.</p>
<p>If you have your private key <strong>in hex</strong>, run the following in your terminal, replacing <code>&lt;&gt;</code> with actual values:</p>
<pre><code class="language-bash">~ $ ./fluence publish \
            --eth_url          http://207.154.232.92:8545 \
            --swarm_url        http://207.154.232.92:8500 \
            --code_path        ~/hello-world/target/wasm32-unknown-unknown/release/hello_world.wasm \
            --gas_price        10 \
            --account          &lt;your ethereum address&gt; \
            --secret_key       &lt;your ethereum private key&gt; \
            --cluster_size     4 \
            --wait_syncing \
            --wait
</code></pre>
<p>If you have a JSON <strong>keystore file</strong>, run the following in your terminal, replacing <code>&lt;&gt;</code> with actual values:</p>
<pre><code class="language-bash">~ $ ./fluence publish \
            --eth_url          http://207.154.232.92:8545 \
            --swarm_url        http://207.154.232.92:8500 \
            --code_path        ~/hello-world/target/wasm32-unknown-unknown/release/hello_world.wasm \
            --gas_price        10 \
            --account          &lt;your ethereum address&gt; \
            --keystore         &lt;path to keystore&gt; \
            --password         &lt;password for keystore&gt; \
            --cluster_size     4 \
            --wait_syncing \
            --wait
</code></pre>
<p>There is more info on using keystore files with Fluence CLI in its <a href="quickstart/../cli/README.html#keystore-json-file">README</a>.</p>
<p>After running the command, you will see an output similar to the following:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0xf5c604478031e9a658551220da3af1f086965b257e7375bbb005e0458c805874
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:03]
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
[3/3]   Transaction was included. ---&gt; [00:02:38]
App deployed.
  app id: 2
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
</code></pre>
<a class="header" href="#check-app-in-the-smart-contract" id="check-app-in-the-smart-contract"><h2>Check app in the smart contract</h2></a>
<p>To see how smart contract sees your app, and what nodes it was deployed onto, you can use <code>status</code> like this:</p>
<pre><code class="language-bash">~ $ ./fluence status \
            --eth_url          http://207.154.232.92:8545 \
            --app_id           &lt;your app id here&gt;
</code></pre>
<p>The output will be in JSON, and look similar to the following:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;&lt;your app id here&gt;&quot;,
      &quot;storage_hash&quot;: &quot;&lt;swarm hash&gt;&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 4,
      &quot;owner&quot;: &quot;&lt;your ethereum address&gt;&quot;,
      &quot;pin_to_nodes&quot;: [],
      &quot;cluster&quot;: {
        &quot;genesis_time&quot;: 1549353504,
        &quot;node_ids&quot;: [
          &quot;0x5ed7aaada4bd800cd4f5b440f36ccece9c9e4542f9808ea6bfa45f84b8198185&quot;,
          &quot;0xb557bb40febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763&quot;,
          &quot;0xac72ccc7886457c3f7da048e184b8b8a43f99c77950e7bb635b6cb3aeb3869fe&quot;,
          &quot;0x9251dd451f4bd9f412173cc21279afc8d885312eb1c21828134ba9095da8306b&quot;,
        ]
      }
    }
  ],
  &quot;nodes&quot;: [
    {
      &quot;validator_key&quot;: &quot;0x5ed7a87da4bd800cd4f5b440f36ccece9c9e4542f9808ea6bfa45f84b8198185&quot;,
      &quot;tendermint_p2p_id&quot;: &quot;0x6c03a3fe792314f100ac8088a161f70bd7d257b1&quot;,
      &quot;ip_addr&quot;: &quot;43.32.21.10&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x5902720e872fb2b0cd4402c69d6d43c86e973db7&quot;,
      &quot;is_private&quot;: false,
      &quot;app_ids&quot;: [
        1,
        2,
        6
      ]
    },
    &quot;&lt;3 more nodes here&gt;&quot;
  ]
}
</code></pre>
<p>You can also use interactive mode instead of default by supplying <code>--interactive</code> flag:</p>
<pre><code class="language-bash">./fluence status \
            --eth_url          http://207.154.232.92:8545 \
            --app_id           &lt;your app id here&gt; \
            --interactive
</code></pre>
<div style="text-align:center">
<img src="../images/interactive.png" width="776px"/>
<br>
</div>
<p>You can press <code>q</code> to exit it.</p>
<p>Your backend now is successfully deployed! You can proceed to access your code from a web browser.</p>
<a class="header" href="#frontend" id="frontend"><h1>Frontend</h1></a>
<p>For this part, you will need installed <code>npm</code>. Please refer to <a href="https://www.npmjs.com/get-npm">npm docs</a> for installation instructions.</p>
<a class="header" href="#preparing-web-app" id="preparing-web-app"><h2>Preparing web app</h2></a>
<p>Let's clone a simple web app template:</p>
<pre><code class="language-bash">~ $ git clone https://github.com/fluencelabs/frontend-template
~ $ cd frontend-template
~/frontend-template $ 
</code></pre>
<p>There are just three files (except for README, LICENSE and .gitignore):</p>
<ul>
<li><code>package.json</code> that declares needed dependencies</li>
<li><code>webpack.config.js</code> needed for the webpack to work</li>
<li><code>index.js</code> that imports <code>fluence</code> js library and shows how to connect to a cluster</li>
</ul>
<p>Let's take a look at <code>index.js</code>:</p>
<pre><code class="language-javascript">
// address of the Fluence smart contract on Ethereum.
let contractAddress = &quot;0x074a79f29c613f4f7035cec582d0f7e4d3cda2e7&quot;;

// Address of the Ethereum node. If set to `undefined`, MetaMask will be used to send transactions.
let ethUrl = &quot;http://207.154.240.52:8545/&quot;;

// appId of the backend as seen in Fluence smart contract.
let appId = &quot;6&quot;;
...
// create a session between client and backend application
fluence.connect(contractAddress, appId, ethUrl).then((s) =&gt; {
  console.log(&quot;Session created&quot;);
  window.session = s;
  helloBtn.disabled = false;
});
...
// set callback on button click
helloBtn.addEventListener(&quot;click&quot;, send)

// send username as a transaction and display results in grettingLbl
function send() {
  const username = usernameInput.value.trim();
  let result = session.invoke(username);
  getResultString(result).then(function (str) {
    greetingLbl.innerHTML = str;
  });
}
</code></pre>
<p>This code queries the Fluence smart contract for IP addresses of Tendermint nodes hosting the app with specified <code>appId</code>, creates an <code>AppSession</code> from these connections, and saves it to <code>window.session</code>, so it can be used later. All this is done via <code>connect</code> method.</p>
<p>Then, it assigns <code>send()</code> function as a callback for clicking the button, which will call an <code>invoke</code> method provided by <code>AppSession</code>. <code>invoke</code> takes a <code>String</code>, and sends it to the backend as a transaction. Result will be displayed in <code>greeting</code> label.</p>
<a class="header" href="#running-and-using" id="running-and-using"><h2>Running and using</h2></a>
<p>Please make sure you have changed <code>appId</code> to the appId of existing backend. If you haven't published your backend yet, please take a look at <a href="quickstart/publish.html">Publishing guide</a>. You can also use backends published by other people, take a look at</p>
<p>To install all dependencies, compile and run the application, run in the terminal:</p>
<pre><code class="language-bash">~/frontend-template $ npm install
~/frontend-template $ npm run start
&gt; frontend-template@1.0.0 start /private/tmp/frontend-template
&gt; webpack-dev-server

ℹ ｢wds｣: Project is running at http://localhost:8080/
...
</code></pre>
<p>Now you can open http://localhost:8080/ in your browser. You will see an input text box and a disabled button. Button will become enabled once AppSession is created. You can enter your name, and press <code>Say hello!</code> button, and greeting will be displayed next to <code>Result:</code>.</p>
<p>You can also open Developer Console, and you'll see a log about session creation:</p>
<pre><code>...
Connecting web3 to http://207.154.232.92:8545
...
Session created
</code></pre>
<div style="text-align:center">
<kbd>
<img src="../images/helloworld.png" width="529px"/>
</kbd>
<br><br><br>
</div>
<p>You can also use Fluence from within Developer console as follows:</p>
<pre><code class="language-javascript">let result = session.invoke(&quot;myName&quot;);
&lt;undefined&gt;
logResultAsString(result);
&lt;undefined&gt;
Hello, world! From user myName
</code></pre>
<a class="header" href="#wrapping-up" id="wrapping-up"><h1>Wrapping up</h1></a>
<p>Thanks for finishing quick start guide!</p>
<p>A short recap of what you have developed and learned:</p>
<ul>
<li>Set up a Rust and Node.js environments from zero to compiling Webassembly backend and a working web application.</li>
<li>Start with Rust basics, and end up using complex procedural macros and processing user input.</li>
<li>Interact with Ethereum and alter Fluence network state.</li>
<li>Spin up real decentralized backend on top of miners' machines, and integrate JavaScript web app with that backend.</li>
</ul>
<p>Hope this was fun. If you experienced any problems with this guide or Fluence, or just want to chat with the team, feel free to join our <a href="https://discordapp.com/invite/AjfbDKQ">Discord</a>!</p>
<p>If you want to do more with Fluence, you can help us out by looking at <a href="quickstart/../unsolved.html">open problems</a> or <a href="https://github.com/fluencelabs/fluence/issues">open issues</a>, and give us some feedback.</p>
<p>Also, there are more examples of <a href="TODO">backends</a> and <a href="TODO">web apps</a>, take a look.</p>
<a class="header" href="#backend-guide" id="backend-guide"><h1>Backend guide</h1></a>
<p>The Fluence network is designed to run Webassembly (Wasm) applications (<code>app</code>) in decentralized trustless environments. Generally, the environment can be considered as several logical parts: a <code>client-side</code> (a frontend part used for sending requests to Wasm program), the <code>VM wrapper</code> (an intermediate layer that receives queries from client side and routes it to an <code>app</code>) and an <code>app</code> written on Wasm:</p>
<p align="center">
  <img src="images/arch_overview.png" alt="Fluence arch overview" width="700px"/>
</p>
<p>Each <code>app</code> should has some features to be able to run on Fluence. They are described in details in <a href="backend/./app_conventions.html">backend application conventions</a>. To simplify <code>app</code> development we introduced a backend SDK (for more information about it please visit to <a href="backend/./sdk_overview.html">sdk overview</a> and <a href="backend/./app_debugging.html">app debugging</a>). If you are stack with some problem while <code>app</code> developing please refer to <a href="backend/./best_practices.html">best practices</a> and <a href="backend/./examples.html">examples</a> sections of this guide.</p>
<a class="header" href="#backend-app-conventions" id="backend-app-conventions"><h1>Backend app conventions</h1></a>
<a class="header" href="#app-lifecycle" id="app-lifecycle"><h2>App lifecycle</h2></a>
<p>The Fluence network backend infrastructure is based on Scala and Rust. Each computation node in the network has the <code>VM wrapper</code> written on Scala that interacts with a backend <code>app</code> written on Wasm and published to the network by developers. To be able to run supplied Wasm code <a href="https://github.com/fluencelabs/asmble">Asmble</a> is used. It compiles supplied Wasm code to a JVM class that then loaded by the <code>VM wrapper</code>. All other interactions between an <code>app</code> and the <code>VM wrapper</code> occur in the <code>VM wrapper</code> process address space without any inter-process communications.</p>
<p>A <code>main</code> module is invoked by the <code>VM wrapper</code> according to the following scheme:</p>
<ol>
<li>
<p>A <code>client-side</code> sends a request to <code>App</code> as a byte array.</p>
</li>
<li>
<p>The <code>VM wrapper</code> calls <code>allocate</code> function of <code>main</code> Wasm module with a size of the array.</p>
</li>
<li>
<p>The <code>VM wrapper</code> writes the array to memory of the module.</p>
</li>
<li>
<p>The <code>VM wrapper</code> calls <code>invoke</code> function from <code>main</code> module with the address returned from <code>allocate</code> function and the array size.</p>
</li>
<li>
<p>The <code>VM wrapper</code> synchronously waits of <code>invoke</code> result. After receiving a <code>pointer</code> from it, reads 4 bytes (that represents <code>size</code> of a byte array) and then reads <code>size</code> bytes from <code>pointer + 4</code> offset (<code>result</code>).</p>
</li>
<li>
<p>The <code>VM wrapper</code> calls <code>deallocate</code> function of <code>main</code> Wasm module with the received pointer.</p>
</li>
<li>
<p>Finally, a <code>result</code> is sent to a <code>client-side</code> as a byte array.</p>
</li>
</ol>
<a class="header" href="#fluence-app-conventions" id="fluence-app-conventions"><h2>Fluence App conventions</h2></a>
<p>There are several restriction and conventions that each supplied <code>app</code> has to be met:</p>
<ol>
<li>
<p>An <code>app</code> can consist of several Wasm modules with different names, but only one of them (let's call it <code>main</code> module and all other as <code>side</code> modules according to the <a href="https://github.com/emscripten-core/emscripten/wiki/Linking#overview-of-dynamic-linking">emcscripten</a>) can be called from <code>user-side</code>. This <code>main</code> module MUST don't have the module name section. This requirement is based on the fact that according to the Wasm specification module name is optional, and now there aren't any possibilities to add it to a generated Wasm binary by default <code>rust</code> compiler.</p>
</li>
<li>
<p>Each <code>main</code> module MUST have three export (in terms of the Wasm specification) functions with names <code>invoke</code>, <code>allocate</code> and <code>deallocate</code>.</p>
</li>
<li>
<p><code>invoke</code> function is used as the <code>main</code> module handler function. It means that all client-side requests are routed to it. The exactly signature of this function MUST be <code>(func (export &quot;invoke&quot;) (param $buffer i32) (param $size i32) (result i32))</code> in wast representation. It receives two i32 params that represent a pointer to supplied argument and its size. If <code>client-side</code> send an empty byte buffer <code>invoke</code> SHOULD be called with two nulls (it means that according to Fluence protocol implementation honest nodes call <code>invoke</code> with nulls but malicious nodes can do anything). This function has to return a pointer to result that MUST have the next structure in memory: <code>| size (4 bytes; little endian) | result buffer (size bytes) |</code>. This convention is based on the fact that Wasm function can return only one value of i32, i64, f32, f64, i128 but there both pointer and size should be returned.</p>
</li>
<li>
<p><code>allocate</code> function MUST have the next signature <code>(func (export &quot;allocate&quot;) (param $size i32) (result i32))</code> in wast representation. It MUST return a pointer as i32 to a module memory region long enough to hold <code>size</code> bytes.</p>
</li>
<li>
<p><code>deallocate</code> function MUST have the next signature <code>(func (export &quot;deallocate&quot;) (param $address i32) (param $size i32) (return))</code>. It is called by the <code>VM wrapper</code> with a pointer to a memory region previously allocated by <code>allocate</code> function and its size. This function SHOULD free this memory region.</p>
</li>
</ol>
<a class="header" href="#fluence-backend-sdk-overview" id="fluence-backend-sdk-overview"><h1>Fluence backend SDK overview</h1></a>
<p>Fluence backend SDK consists of two crates: <code>main</code> and <code>macro</code>. The first one is used for all memory relative operations and logging (please find more information in <a href="backend/./app_debugging.html">app debugging</a> section). The second one contains a procedural macro to simplify the entry function's signature. These crates can be used separately but the more preferred way is using the global <code>fluence</code> crate that reexports all others. In <code>Rust 2018 edition</code> it can be done by simply adding <code>use fluence::sdk::*</code> to the source.</p>
<a class="header" href="#writing-app-without-sdk" id="writing-app-without-sdk"><h2>Writing app without SDK</h2></a>
<p>For a start, let's review how a simple <code>hello-world</code> <code>app</code> is made without Fluence backend SDK on pure Rust. From <a href="backend/app_conventions.html">fluence backend conventions</a> it follows that each <code>app</code> must have a <code>main</code> module with three export functions. Keeping in mind restrictions to their signatures, a basic structure of a <code>main</code> module can look like that:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; usize {
    ...
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    ...
}

#[no_mangle]
pub unsafe fn deallocate(ptr: *mut u8, size: usize) {
    ...
}
</code></pre>
<p>Note that <code>#[no_mangle]</code> and <code>pub unsafe</code> parts of function signature manage function to be exported from a Wasm module (for more information please refer to this <a href="https://internals.rust-lang.org/t/precise-semantics-of-no-mangle/4098">discussion</a>).</p>
<p>The <code>hello-world</code> example without SDK from the <a href="backend/../quickstart/rust.html">quick start</a> can be implemented like this:</p>
<pre><code class="language-Rust">#![feature(allocator_api)]

use std::alloc::{Alloc, Global, Layout};
use std::mem;
use std::num::NonZeroUsize;
use std::ptr::{self, NonNull};

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; NonNull&lt;u8&gt; {
    let raw_string = Vec::from_raw_parts(ptr, len, len);
    let user_name = String::from_utf8(raw_string).unwrap();

    let result = format!(&quot;Hello, world! From user {}&quot;, user_name);
    const RESULT_SIZE_BYTES: usize = 4;

    let result_len = result.len();
    let total_len = result_len
        .checked_add(RESULT_SIZE_BYTES)
        .expect(&quot;usize overflow occurred&quot;);

    // converts array size to bytes in little-endian
    let len_as_bytes: [u8; RESULT_SIZE_BYTES] = mem::transmute((result_len as u32).to_le());

    // allocates a new memory region for the result
    let result_ptr = allocate(total_len);

    // copies length of array to memory
    ptr::copy_nonoverlapping(
        len_as_bytes.as_ptr(),
        result_ptr.as_ptr(),
        RESULT_SIZE_BYTES,
    );

    // copies array to memory
    ptr::copy_nonoverlapping(
        result.as_ptr(),
        result_ptr.as_ptr().add(RESULT_SIZE_BYTES),
        result_len,
    );

    result_ptr
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    let non_zero_size =
        NonZeroUsize::new(size).expect(&quot;[Error]: allocation of zero bytes is not allowed.&quot;);
    let layout: Layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())
        .unwrap_or_else(|_| panic!(&quot;[Error]: layout creation failed while allocation&quot;));
    Global
        .alloc(layout)
        .unwrap_or_else(|_| panic!(&quot;[Error]: allocation of {} bytes failed&quot;, size))
}

#[no_mangle]
pub unsafe fn deallocate(ptr: NonNull&lt;u8&gt;, size: usize) {
    let non_zero_size =
        NonZeroUsize::new(size).expect(&quot;[Error]: deallocation of zero bytes is not allowed.&quot;);
    let layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())
        .unwrap_or_else(|_| panic!(&quot;[Error]: layout creation failed while deallocation&quot;));;
    Global.dealloc(ptr, layout);
}
</code></pre>
<p>The full working code of this example can be found <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world/app-without-sdk">here</a>.</p>
<a class="header" href="#fluence-sdk-usage" id="fluence-sdk-usage"><h2>Fluence SDK usage</h2></a>
<p>From the example above it can be seen that <code>allocate</code> and <code>deallocate</code> functions serve only utility purpose and are normally used only by the <code>VM wrapper</code>. These functions aren't any that most of the developers would want to implement in their <code>app</code>. Fluence backend SDK provides <code>fluence::memory::alloc</code> and <code>fluence::memory::dealloc</code> functions also based on <a href="https://doc.rust-lang.org/beta/std/alloc/trait.GlobalAlloc.html">GlobalAlloc</a>. They exported by default after including the sdk and can be disabled by including it with <code>fluence = {default-features = false}</code>.</p>
<p>The <code>invoke</code> function can be also simplified by using the Fluence backend SDK that provides <code>fluence::memory::write_result_to_mem</code> and <code>fluence::memory::read_input_from_mem_</code> in this way:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(_ptr: *mut u8, _len: usize) -&gt; usize {
    let test_str = &quot;Hello, world!&quot;;
    fluence::memory::write_result_to_mem(test_str)
        .unwrap_or_else(|_| {
            panic!(&quot;[Error] Putting the result string into a raw memory was failed&quot;)
        })
        .as_ptr() as usize
}
</code></pre>
<a class="header" href="#invocation-handler-to-the-rescue" id="invocation-handler-to-the-rescue"><h3>Invocation handler to the rescue</h3></a>
<p>The example above can be simplified a little bit more using procedural macros <code>invocation_handler</code> as the <code>hello-world</code> example mentioned in <a href="TODO">quick start</a> example:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
</code></pre>
<p>Internally this macro creates a new function <code>invoke</code> that converts a raw argument to the appropriate format, calls <code>f</code> and then converts its result via <code>memory::write_result_to_mem</code> from <code>fluence_sdk_main</code>. The following listing shows how this macro is expanded:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; std::ptr::NonNull&lt;u8&gt; {
    let arg = memory::read_input_from_mem(ptr, len);
    let arg = String::from_utf8(arg).unwrap();
    let result = greeting(arg);
    memory::write_result_to_mem(result.as_bytes()).expect(&quot;Putting result string to memory has failed&quot;)
}
</code></pre>
<p>To use this macro with a function <code>f</code> some conditions have to be satisfied:</p>
<ol>
<li>
<p><code>f</code> mustn't have more than one input argument.</p>
</li>
<li>
<p><code>f</code> mustn't be <code>unsafe</code>, <code>const</code>, generic, have custom abi linkage or variadic param.</p>
</li>
<li>
<p>The type of <code>f</code> input (if it present) and output parameters have to be one of {String, Vec<u8>} set.</p>
</li>
<li>
<p><code>f</code> mustn't have the name <code>invoke</code>.</p>
</li>
</ol>
<p>For troubleshooting and macros debugging <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> can be used.</p>
<p>The macro also has an <code>init_fn</code> attribute that can be used for specifying initialization function name. This function will be called only in the first <code>invoke</code> function call. It can be used like this:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() {
    ...
}

#[invocation_handler(init_fn = init)]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>This is expanded to</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() { 
    ...
}

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello from Fluence to {}&quot;, name)
}

static mut IS_INITED: bool = false;

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; std::ptr::NonNull&lt;u8&gt; {
    if !IS_INITED { 
        init();
        unsafe { IS_INITED = true; }
    }
    let arg = memory::read_input_from_mem(ptr, len);
    let arg = String::from_utf8(arg).unwrap();
    let result = greeting(arg);
    memory::write_result_to_mem(result.as_bytes()).expect(&quot;Putting result string to memory has failed&quot;)
}
</code></pre>
<p>Example of usage <code>invocation_handler</code> with <code>init_fn</code> attribure can be found <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">here</a>.</p>
<a class="header" href="#rust-edition-2015" id="rust-edition-2015"><h2>Rust edition 2015</h2></a>
<p>To use Fluence SDK with <code>Rust 2015 edition</code> please import it like this:</p>
<pre><code class="language-Rust">#![feature(custom_attribute)]
extern crate fluence;

use fluence::sdk::*;
</code></pre>
<p>Example of <code>hello-world2</code> <code>app</code> on <code>Rust edition 2015</code> can be found <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2015">here</a>.</p>
<a class="header" href="#backend-app-debugging" id="backend-app-debugging"><h1>Backend app debugging</h1></a>
<a class="header" href="#wasm-logger" id="wasm-logger"><h2>Wasm logger</h2></a>
<p>There are a few debugging capabilities for Wasm program. The Fluence network provides a possibility to so-called print-debugging. It can be included by specifying the <code>wasm_logger</code> feature of the sdk.</p>
<p>The logger is implemented as a logging facade for crate <a href="https://github.com/rust-lang-nursery/log">log</a>. It means that all <code>log</code> crate possibilities can be used as usual. Let's review it by the example of <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">hello-world2</a> application with simple logging:</p>
<pre><code class="language-Rust">use fluence::sdk::*;
use log::info;

fn init() {
    logger::WasmLogger::init_with_level(log::Level::Info).is_ok()
}

#[invocation_handler(init_fn = init)]
fn main(name: String) -&gt; String {
    info!(&quot;{} has been successfully greeted&quot;, name);
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>The easiest way to initialize the logger is using the <code>init_fn</code> attribute of <code>invocation_handler</code> like in the example above.</p>
<p>Please also note that this <code>logger</code> is designed only for Wasm environment and Fluence <code>WasmVm</code>. Don't use it for other targets and virtual machines. But if it needs to create a project with <code>logger</code> either for Wasm target and other architectures, a conditional compilation can be used:</p>
<pre><code class="language-Rust">fn init() {
    if cfg!(target_arch = &quot;wasm32&quot;) {
        logger::WasmLogger::init_with_level(log::Level::Info).unwrap();
    } else {
        simple_logger::init_with_level(log::Level::Info).unwrap();
    }
}
</code></pre>
<p>Without this trick <code>app</code> that uses the logger can be compiled only for <code>wasm32-unknown-unknown</code> target.</p>
<p>It is also important to note that by default debugging capabilities is disabled in the Fluence network because of verification game process (you can find more information about it in <a href="TODO">our paper</a>).</p>
<a class="header" href="#app-runner" id="app-runner"><h2>App runner</h2></a>
<p>Sometimes it needs not only a debug output but a possibility to run a compiled Wasm <code>app</code> with some different inputs. It can be done by using so-called runner written on Scala (because it uses a <code>WasmVm</code> implementation that also written on Scala).</p>
<p>Let's a dig a little bit into the <code>hello-world2</code> <a href="(https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/runner)">runner</a>. It receives a path to a Wasm binary as the first CLI argument, then creates a <code>vm</code> object that extends <code>WasmVm</code> trait. During this creation, Wasm code is compiled by Asmble to JVM and loaded into VM. This trait has two public methods: <code>invoke</code> that manages requests to <code>app</code> and <code>getVmState</code> that computes a hash of significant inner state. In the following code snippet</p>
<pre><code class="language-Scala">      inputFile &lt;- EitherT(getWasmFilePath(args).attempt)
        .leftMap(e =&gt; InternalVmError(e.getMessage, Some(e)))
        
      vm ← WasmVm[IO](NonEmptyList.one(inputFile), &quot;fluence.vm.debugger&quot;)
      
      initState ← vm.getVmState[IO]

      result1 ← vm.invoke[IO](None, &quot;John&quot;.getBytes())
</code></pre>
<p><code>inputFile</code> points to a supplied path to wasm file. Then WasmVm instance is created with the path to input file and <code>fluence.vm.debugger</code> config. This config (for the <code>hello-world2</code> <code>app</code> it can be found <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/hello-world2/runner/src/main/resources/reference.conf">here</a>) contains some useful settings that control some inner VM creation process a little bit:</p>
<ul>
<li>
<p><code>defaultMaxMemPages</code> - the maximum number of memory pages when a module doesn't specify it, each Wasm page according to the specification contains 65536 bytes (64 by default, 65536*64 = 4MB)</p>
</li>
<li>
<p><code>loggerRegister</code> - if &gt; 0, registers the logger Wasm module as <code>logger</code> with specified number of memory pages, that allows to logs to stdout (0  by default in mainnet and 2 by default for runners)</p>
</li>
<li>
<p><code>allocateFunctionName</code> - the name of function that should be called for memory allocation (<code>allocate</code> by default)</p>
</li>
<li>
<p><code>deallocateFunctionName</code> - the name of function that should be called for deallocation of previously allocated memory by <code>allocateFunction</code> (<code>deallocate</code> by default)</p>
</li>
<li>
<p><code>invokeFunctionName</code> - the name of the main module handler function (<code>invoke</code> by default)</p>
</li>
</ul>
<p>Then the hash of internal state is computed by <code>vm.getVmState</code> and <code>invoke</code> from <code>app</code> is called by <code>vm.invoke</code>.</p>
<a class="header" href="#examples" id="examples"><h1>Examples</h1></a>
<ul>
<li><a href="#hello-world">Hello-world</a></li>
<li><a href="#hello-world2-with-logging">Hello-world2</a></li>
<li><a href="#llamadb">Llamadb</a></li>
<li><a href="#tic-tac-toe">Tic-tac-toe</a>
<ul>
<li><a href="#function-routing-scheme">Function routing scheme</a></li>
<li><a href="#memory-management">Memory management</a></li>
</ul>
</li>
</ul>
<p>In this section, some examples of backend applications are described.</p>
<a class="header" href="#hello-world" id="hello-world"><h2>Hello-world</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world">Hello-world</a> is a simple demo <code>app</code> for the Fluence network that shows basic usage of the Fluence backend SDK.</p>
<a class="header" href="#hello-world2-with-logging" id="hello-world2-with-logging"><h2>Hello-world2 with logging</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">Hello-world2</a> is a simple demo app for the Fluence network that shows either a basic usage and the logger feature of the Fluence backend SDK.</p>
<a class="header" href="#llamadb" id="llamadb"><h2>Llamadb</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/llamadb">Llamadb</a> <code>app</code> is an example of adopting the existing in-memory SQL database to the Fluence network. This <code>app</code> is based on the original <a href="https://github.com/fluencelabs/llamadb">llamadb</a> database. Since it is in-memory database and doesn't use multithreading and I/O it can be easily ported to the Fluence. All that needs to do it is just a simple <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/llamadb/src/lib.rs">wrapper</a> that receives requests from a <code>client-side</code>, manages it to the original <code>llamadb</code> and returns results.</p>
<a class="header" href="#tic-tac-toe" id="tic-tac-toe"><h2>Tic-tac-toe</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/tic-tac-toe">Tic-tac-toe</a> <code>app</code> is an example of proper memory management and function routing scheme through JSON. This <code>app</code> provides us with a bunch of public methods:</p>
<ul>
<li>
<p><code>create_payer</code> - creates a new player with a given player name</p>
</li>
<li>
<p><code>create_game</code> - creates a new game for the provided player</p>
</li>
<li>
<p><code>move</code> - makes user and <code>app</code> moves sequentially, returns <code>app</code> move coordinates</p>
</li>
<li>
<p><code>get_game_state</code> - returns a state of a game for the given user (includes board state and user tile)</p>
</li>
<li>
<p><code>get_statistics</code> - returns overall game statistics includes how registered players count, created game and total moves count</p>
</li>
</ul>
<a class="header" href="#function-routing-scheme" id="function-routing-scheme"><h3>Function routing scheme</h3></a>
<p>Since some public api functions receive different parameters, it needs a way to choose one of them with appropriate settings. There are several input data format that could be used to reach our goal, but we decided to use JSON as one of the most popular that uses text to transmit data objects consisting of key-value pairs.</p>
<p>On the other side, one of the most popular JSON parser for Rust is a <a href="https://github.com/serde-rs/serde">serde</a> library. Serde provides <code>serde_json::from_str</code> method that parses string to a set of <code>serde_json::Value</code> enums and <code>serde_json::from_value</code> method that can translate <code>Value</code> to a concrete struct. It is handy to parsing JSONs that have the same part.</p>
<p>Let's review its usage on an example of <code>do_request</code> function realization:</p>
<pre><code class="language-Rust">fn do_request(req: String) -&gt; AppResult&lt;Value&gt; {
    let raw_request: Value = serde_json::from_str(req.as_str())?;
    let request: Request = serde_json::from_value(raw_request.clone())?;

    match request.action.as_str() {
        &quot;move&quot; =&gt; {
            let player_move: PlayerMove = serde_json::from_value(raw_request)?;
            GAME_MANAGER.with(|gm| {
                gm.borrow()
                    .make_move(request.player_name, player_move.coords)
            })
        }
        ...
        &quot;create_game&quot; =&gt; {
            let player_tile: PlayerTile = serde_json::from_value(raw_request)?;
            let player_tile = game::Tile::from_char(player_tile.tile).ok_or_else(|| {
                &quot;incorrect tile type, please choose it from {'X', 'O'} set&quot;.to_owned()
            })?;

            GAME_MANAGER.with(|gm| {
                gm.borrow_mut()
                    .create_game(request.player_name, player_tile)
            })
        }

}
</code></pre>
<p>It can be viewed that at first <code>req</code> is parsed to <code>serde_json::Value</code> (and this parsing is occurred only once), then the result is parsed to a <code>Request</code> struct same for all requests. This struct contains <code>action</code> and <code>player_name</code> fields. After this parsing routing could be done by <code>action</code> field value. Each action can has it own request structure and additional parsing to a concrete structure can be done in the same way (please refer to <code>move</code> and <code>create_game</code> cases from the above example).</p>
<a class="header" href="#memory-management" id="memory-management"><h3>Memory management</h3></a>
<p>Proper memory management is a cornerstone of application that provides capabilities to store some user-supplied data. In tic-tac-toe, it is solved by using a fixed-size collection for all internal objects that can be of two types: <code>Player</code> and <code>Game</code>. <code>Player</code> includes a string that represents its name and <code>Game</code> contains board state and a tile chosen by a user.</p>
<p>Since <code>create_player</code> allows to create an infinite count of <code>Player</code>, they could exhaust all <code>app</code> memory. <a href="https://github.com/andylokandy/arraydeque">ArrayDeque</a> manages to solve this problem by providing a fixed size queue that can pop up an object from the front while exceeding the limit.</p>
<p>Then consider a situation when each user can play to several games or the size of <code>Game</code> is too big compared to the size of <code>Player</code> to give an example that is more close to real applications. In this situation, one of the approaches is to use a separate queue for <code>Game</code> objects (of cause <code>Game</code> can be saved into a <code>Player</code> even in vector or map but consider a more complex design that gives more control on memory management). To implement it each <code>Player</code> should have an smth like the id of a proper <code>Game</code> object. Since all of them are placed in the queue that can change its position in some time, the only way is using smart pointers. It this example there are two queues that own <code>Player</code> and <code>Game</code> objects (it means that they store a strong Rc ptr to them) and <code>Player</code> has a weak ptr to a proper <code>Game</code> object.</p>
<p>Also, it would be good to find <code>Player</code> object by name faster than <code>O(n)</code>. To reach it <code>HashMap</code> can be used. And because of our design, <code>HashMap</code> should also contain weak pointers to players. According to all of these, the final structure could look like this:</p>
<pre><code class="language-Rust">pub struct GameManager {
    players: ArrayDeque&lt;[Rc&lt;RefCell&lt;Player&gt;&gt;; PLAYERS_MAX_COUNT], Wrapping&gt;,
    games: ArrayDeque&lt;[Rc&lt;RefCell&lt;Game&gt;&gt;; GAMES_MAX_COUNT], Wrapping&gt;,
    players_by_name: HashMap&lt;String, Weak&lt;RefCell&lt;Player&gt;&gt;&gt;,
}
</code></pre>
<a class="header" href="#authentication" id="authentication"><h3>Authentication</h3></a>
<p>TBD</p>
<a class="header" href="#best-practices" id="best-practices"><h1>Best practices</h1></a>
<a class="header" href="#memory-management-in-app" id="memory-management-in-app"><h2>Memory management in app</h2></a>
<p>Please pay attention to module memory usage - each <code>app</code> can have maximum 4Gb of heap. But in many situations <code>app</code> can have public API that explicitly or indirectly consumes module memory (e.g., by saving some user data). So attackers can make a DoS attack to such <code>app</code>. Usually, proper memory management can be reached by using fix-size collections like <a href="https://github.com/andylokandy/arraydeque">ArrayDeque</a>. In future Fluence backend SDK will provide some other collections for that.</p>
<p>One example of careful memory management can be found in <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/tic-tac-toe">tic-tac-toe</a>.</p>
<a class="header" href="#shrinking-app-code-size" id="shrinking-app-code-size"><h2>Shrinking app code size</h2></a>
<p>There are some techniques for reducing size of a generated <code>app</code>. Most of them can be found in this excellent <a href="https://rustwasm.github.io/book/reference/code-size.html">chapter</a> of <code>Rust and WebAssembly</code> book. But as for the Fluence network to reduce the size of binary as much is possible <code>no_std</code> crate without SDK can be used. The example of <code>hello-world</code> implemented without the SDK can be found in <a href="backend/sdk_overview.html">Fluence backend SDK overview</a>.</p>
<a class="header" href="#panics" id="panics"><h2>Panics</h2></a>
<p>Using of <code>unwrap</code>, <code>expect</code> and others like these are possible in an <code>app</code>. Each of them leads to an exception that will catch in the <code>VM wrapper</code>. A error message of such exception won't be much informative in this case (like this <code>{&quot;Error&quot;:{&quot;code&quot;:&quot;TrapError&quot;,&quot;message&quot;:&quot;Function invoke with args: List(1117056, 53) was failed&quot;,&quot;cause&quot;:&quot;Function invoke with args: List(1117056, 53) was failed&quot;}}</code>), but <code>app</code> will be in a consistent state and could process other requests.</p>
<ul>
<li><a href="#fluence-miner-guide">Fluence miner guide</a>
<ul>
<li><a href="#how-mining-works">How mining works</a></li>
<li><a href="#how-to-become-a-fluence-miner">How to become a Fluence miner</a>
<ul>
<li><a href="#deploy-fluence-node-to-a-cloud">Deploy Fluence node to a cloud</a></li>
<li><a href="#deploy-fluence-node-locally">Deploy Fluence node locally</a></li>
</ul>
</li>
<li><a href="#how-to-check-if-node-is-registered">How to check if node is registered</a></li>
<li><a href="#private-nodes-and-application-pinning">Private nodes and application pinning</a>
<ul>
<li><a href="#private-nodes">Private nodes</a></li>
<li><a href="#application-pinning">Application pinning</a>
<ul>
<li><a href="#mixing-pinning-and-matching">Mixing pinning and matching</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#how-to-remove-a-node-from-the-fluence-smart-contract">How to remove a node from the Fluence smart contract</a></li>
<li><a href="#tips-and-tricks">Tips and tricks</a></li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-miner-guide" id="fluence-miner-guide"><h1>Fluence miner guide</h1></a>
<p>Being a miner in Fluence network means that you will provide you computation power to host decentralized backends. In order to do that, you will need just a few things:</p>
<ol>
<li>A computer to run a Fluence node and workers on it</li>
<li>Installed and running Docker and <code>docker-compose</code></li>
<li>Installed python2 pip</li>
<li>An Ethereum light-client or full node connected to Rinkeby testnet</li>
<li>A Rinkeby Ethereum wallet topped up with some ETH to submit transactions</li>
</ol>
<a class="header" href="#how-mining-works" id="how-mining-works"><h2>How mining works</h2></a>
<p>The process is as follows:
You run a Docker image with Fluence node on your computer, then you register that node within Fluence smart contract by using Fluence CLI. On registration, you specify max number of backends you wish to host, so your node doesn't run out of resources.</p>
<p>After you registered your node within smart contract, it starts waiting to be included in an application cluster. That will happen when someone publishes an app and the Fluence smart contract will match that app to your node, and then send an Ethereum event that your node is listening to.</p>
<p>When node receives an event stating it's a part of an application cluster now, it will download application code from Swarm, and then run a Docker image with Fluence worker hosting that code.</p>
<a class="header" href="#how-to-become-a-fluence-miner" id="how-to-become-a-fluence-miner"><h2>How to become a Fluence miner</h2></a>
<p>The first step is to deploy a Fluence node. Deploy is automated, you can get scripts by cloning <a href="https://github.com/fluencelabs/fluence">Fluence repo</a>:</p>
<pre><code>git clone https://github.com/fluencelabs/fluence
</code></pre>
<a class="header" href="#deploy-fluence-node-to-a-cloud" id="deploy-fluence-node-to-a-cloud"><h3>Deploy Fluence node to a cloud</h3></a>
<p>It's an automated task, you will only need to specify your cloud instance IP addresses and your Ethereum wallet, and then run a (Fabric)[https://github.com/fabric/fabric] script.</p>
<p>First, let's install Fabric:</p>
<pre><code class="language-bash"># make use you're using python2
$ pip --version
pip 18.0 from &lt;...&gt; (python 2.7)
$ pip install Fabric==1.14.1
</code></pre>
<p>It should install fabric 1.14.1. <strong>Be careful not to install Fabric 2 as it's not current supported.</strong></p>
<p>Next, open <a href="../../tools/deploy/instances.json">fluence/tools/deploy/instances.json</a> in your favorite text editor, and modify config:</p>
<pre><code class="language-json">{
    &quot;&lt;ip1&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account1&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key1&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    },
    &quot;&lt;ip2&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account2&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key2&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    }
}

</code></pre>
<p>You can specify here several nodes, but for the sake of example, let's continue with a single node. After filling info in deploy_config.json, it should look similar to this:</p>
<pre><code class="language-json">{
    &quot;53.42.31.20&quot;: {
        &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
        &quot;key&quot;: &quot;4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7&quot;,
        &quot;api_port&quot;: &quot;25000&quot;,
        &quot;capacity&quot;: 10
    }
}
</code></pre>
<p>You can also change user running setup commands on cloud instance by <code>env.user</code> to desired username.</p>
<pre><code class="language-python"># Set the username
env.user = &quot;root&quot;
</code></pre>
<p>Now, let's deploy Fluence node along with Geth and Swarm containers:</p>
<pre><code class="language-bash">$ fab deploy
</code></pre>
<p>At the end of the successful deployment you should see something like the following:</p>
<pre><code>[53.42.31.20] out: CONTRACT_ADDRESS=0x074a79f29c613f4f7035cec582d0f7e4d3cda2e7
[53.42.31.20] out: NAME=fluence-node-1
[53.42.31.20] out: HOST_IP=53.42.31.20
[53.42.31.20] out: EXTERNAL_HOST_IP=53.42.31.20
[53.42.31.20] out: OWNER_ADDRESS=0x00a329c0648769a73afac7f9381e08fb43dbea72
...
[53.42.31.20] out: Node container is started.
[53.42.31.20] out: CURRENT NODE = 1
[53.42.31.20] out: TENDERMINT_KEY=YAa6x36acTUIemAoejyplm+cUKe5rhTC1ArMPLMfvFY=
[53.42.31.20] out: API_PORT=25000
[53.42.31.20] out: CAPACITY=10
</code></pre>
<p>Here you have some useful information that you can use with Fluence CLI.</p>
<p>At the very end, you should see something like this:</p>
<pre><code>[53.42.31.20] out: [1/2]   Node synced. ---&gt; [00:00:00]
[53.42.31.20] out: [2/2]   Node added. ---&gt; [00:00:00]
[53.42.31.20] out: Node registered. Submitted transaction: 0x51e1dcf1cf20e136ce66d240e9897c329894c1084e55b13a4fab751fbaced981
</code></pre>
<p>That's the result of script registering your node within Fluence smart contract. You can see it in <a href="../../tools/deploy/scripts/compose.sh">compose.sh</a>:</p>
<pre><code class="language-bash">./fluence register \
        --node_ip           $EXTERNAL_HOST_IP \
        --tendermint_key    $TENDERMINT_KEY \
        --contract_address  $CONTRACT_ADDRESS \
        --account           $OWNER_ADDRESS \
        --secret_key        $PRIVATE_KEY \
        --api_port          $API_PORT \
        --capacity          $CAPACITY \
        --wait_syncing \
        --base64_tendermint_key
</code></pre>
<p>All environment variables used in the command are listed in the useful information above, so you can easily use them with Fluence CLI.</p>
<a class="header" href="#deploy-fluence-node-locally" id="deploy-fluence-node-locally"><h3>Deploy Fluence node locally</h3></a>
<p>If you wish to use your local computer to host Fluence node, you can do that by running <a href="../../tools/deploy/scripts/rinkeby-compose.sh">rinkeby-compose.sh</a> like this:</p>
<pre><code># ./rinkeby-compose.sh &lt;external-ip&gt; &lt;owner-address&gt; &lt;private-key&gt; &lt;api-port&gt; &lt;capacity&gt;
./rinkeby-compose.sh 53.42.31.20 0x00a329c0648769a73afac7f9381e08fb43dbea72 4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 25000 10
</code></pre>
<a class="header" href="#how-to-check-if-node-is-registered" id="how-to-check-if-node-is-registered"><h2>How to check if node is registered</h2></a>
<p>You can use <a href="roles/../../cli/README.html">Fluence CLI</a> to query current state of network in Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence status
</code></pre>
<p><strong>Note:</strong> if your Ethereum node is remote, you can specify it's address via <code>--eth_url</code> option, like this:</p>
<pre><code class="language-bash">./fluence status --eth_url https://53.42.31.20:8545
</code></pre>
<p>You should see your Ethereum address under <code>owner</code> in <code>nodes</code> list. Similar to this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0x6006bac77e9a7135087a60287a3ca9966f9c50a7b9ae14c2d40acc3cb31fbc56&quot;,
      &quot;tendermint_key&quot;: &quot;0x4b4432951f27c2e9a29017b3b6dee46a2e08c3a2&quot;,
      &quot;ip_addr&quot;: &quot;53.42.31.20&quot;,
      &quot;api_port&quot;: 25001,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
      &quot;is_private&quot;: false,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>Please refer to Fluence CLI <a href="roles/../../cli/README.html">README</a> for more info on installation and usage.</p>
<a class="header" href="#private-nodes-and-application-pinning" id="private-nodes-and-application-pinning"><h2>Private nodes and application pinning</h2></a>
<a class="header" href="#private-nodes" id="private-nodes"><h3>Private nodes</h3></a>
<p>By default, after you register a node in the Fluence smart contract, any matching code could be deployed on it. So the node is publici by default.</p>
<p>But if you want to host only your app, there is a way to mark node <strong>private</strong>. That could be to be sure about what apps you're hosting, what's their workload or just to be sure <em>your</em> app gets enough resources to be ran.</p>
<p>When a node is marked as <strong>private</strong>, only your apps can be deployed on that node. This is determined by the Ethereum address that sent the transaction for node registration and for application deployment.</p>
<p>The following command will register a private node:</p>
<pre><code class="language-bash">./fluence register \
            --private \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \
            --contract_address      0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account               0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --base64_tendermint_key \
            --secret_key            0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>As suggested by it's name, it's the <code>--private</code> flag what's making the registered node a private one.</p>
<p>Now, only apps <a href="roles/backend.html">published</a> to Fluence smart contract from your Ethereum address can get deployed on your nodes. <strong>But these apps need to specify nodes they should be hosted on</strong>, that's called <strong>application pinning</strong>.</p>
<a class="header" href="#application-pinning" id="application-pinning"><h3>Application pinning</h3></a>
<p>So, since your nodes are <a href="#private-nodes">private</a>, the application publishing process changes a little: you need to specify IDs of the nodes where you want the application to be hosted. With CLI, that's pretty easy. Assuming you have registered 4 private nodes, and their IDs are:</p>
<ul>
<li><code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code></li>
<li><code>QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI=</code></li>
<li><code>+l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY=</code></li>
<li><code>xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE=</code></li>
</ul>
<p>All you have to do is to provide these node ids to <code>--pin_to</code> flag as a space-separated list:</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \
            --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     4 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p><em>Note that you can pin your app to your both <strong>private</strong> and <strong>public</strong> nodes.</em> Marking node as private just prevents random apps to be deployed on that node.</p>
<a class="header" href="#mixing-pinning-and-matching" id="mixing-pinning-and-matching"><h4>Mixing pinning and matching</h4></a>
<p>The command above is a perfect match, it's pinning the app to four nodes, and also specifies a cluster size of four, so every node hosting the app is directly pinned to it.</p>
<p>But what if your app requires more nodes than you wish to register? In that case, you can pin your app to any number of nodes, be it just one or a few, and specify a cluster size that you need. Fluence smart contract will then match your app both against your pinned nodes and available public nodes. The command is almost the same, except the <code>--cluster_size</code> requires eight nodes.</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        /Users/folex/Development/fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     8 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p>So, assuming contract has just four registered nodes and one app, the <code>./fluence status --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a</code> will look like this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,
      &quot;storage_hash&quot;: &quot;0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 8,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
        &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
        &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
        &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;
      ],
      &quot;cluster&quot;: null
    }
  ],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180rfc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>You see app's <code>cluster</code> is <code>null</code>, that means it's not deployed yet, waiting for enough nodes to be available.</p>
<a class="header" href="#how-to-remove-a-node-from-the-fluence-smart-contract" id="how-to-remove-a-node-from-the-fluence-smart-contract"><h2>How to remove a node from the Fluence smart contract</h2></a>
<p>If you shut down your node, it's not available anymore for any reason, or you just want to stop it hosting apps, you can remove the node from the Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence delete_node \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --tendermint_key   1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64_tendermint_key
</code></pre>
<a class="header" href="#tips-and-tricks" id="tips-and-tricks"><h2>Tips and tricks</h2></a>
<p>CLI has some neat features not described in that guide:</p>
<ul>
<li>Wait until your Ethereum is fully synced</li>
<li>Wait until the transaction is included in a block, printing additional info from contract</li>
<li>Look at smart contract <code>status</code> via interactive command-line table viewer</li>
</ul>
<p>All these features are described in <a href="roles/../../cli/README.html#tips-and-tricks">CLI's readme</a>, so take a look!</p>
<a class="header" href="#fluence-tools-and-sdks" id="fluence-tools-and-sdks"><h1>Fluence tools and SDKs</h1></a>
<ul>
<li><a href="tools/cli_README.html">CLI</a> to interact with Fluence smart contract.</li>
</ul>
<ul>
<li><a href="tools/rust_README.html">Rust SDK</a> will help building a backend in Rust. Also, see the <a href="tools/../quickstart/rust.html">backend quick start</a>.</li>
</ul>
<ul>
<li><a href="tools/js_README.html">JS SDK</a> to interact with backends deployed on top of Fluence. See the <a href="tools/../quickstart/web.html">frontent quick start</a> to learn how to use it.</li>
</ul>
<ul>
<li><a href="#fluence-cli">Fluence CLI</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-examples">Usage examples</a>
<ul>
<li><a href="#register-a-node">Register a node</a></li>
<li><a href="#publish-an-app">Publish an app</a>
<ul>
<li><a href="#waiting-for-an-app-to-be-deployed-or-enqueued">Waiting for an app to be deployed or enqueued</a></li>
</ul>
</li>
<li><a href="#delete-an-app">Delete an app</a></li>
<li><a href="#retrieve-fluence-network-state-as-json">Retrieve Fluence network state as JSON</a>
<ul>
<li><a href="#filtering-status">Filtering status</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tips-and-tricks">Tips and tricks</a>
<ul>
<li><a href="#waiting-for-an-ethereum-node-to-sync">Waiting for an Ethereum node to sync</a></li>
<li><a href="#waiting-for-a-transaction-to-be-included-in-a-block">Waiting for a transaction to be included in a block</a></li>
<li><a href="#interactive-status">Interactive status</a></li>
<li><a href="#authorization-and-private-keys">Authorization and private keys</a>
<ul>
<li><a href="#keystore-json-file">Keystore JSON file</a></li>
<li><a href="#private-key">Private key</a></li>
<li><a href="#password">Password</a></li>
<li><a href="#no-authorization">No authorization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-cli" id="fluence-cli"><h2>Fluence CLI</h2></a>
<p>Fluence CLI is an automation tool for tasks of app management (deployment and deletion), computation resource sharing (node registration), and monitoring Fluence network state (status). See usage for more info.</p>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<p>CLI assumes running Ethereum and Swarm on <code>http://localhost:8545/</code> and <code>http://localhost:8500/</code> respectively. Use <code>--eth_url</code> and <code>--swarm_url</code> to specify actual addresses as you need.</p>
<p>Please note, that your Ethereum account should have sufficient funds for issuing transactions to smart-contract. It's only for transaction fees, Fluence itself doesn't currently charge miners or developers. That could change in the future, for example when miners' deposits are implemented.</p>
<p>Also, take a look at <a href="tools/../tools/deploy/README.html">deployment scripts</a>, they will assist you in running Swarm, Ethereum and Fluence nodes.</p>
<a class="header" href="#installation" id="installation"><h2>Installation</h2></a>
<p>Requirements: <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>cargo</code></a> and <a href="https://www.npmjs.com/get-npm"><code>npm</code></a> are needed.</p>
<ul>
<li>clone this repo and <code>cd</code> to <code>cli</code> folder</li>
<li>run <code>cargo build</code></li>
<li>go to <code>target/debug</code></li>
<li>there is an executable file <code>fluence</code> to work with</li>
</ul>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>To look at all possible arguments and options use <code>./fluence --help</code>:</p>
<p>You can use <code>./fluence [SUBCOMMAND] --help</code> to learn how to use commands.</p>
<a class="header" href="#usage-examples" id="usage-examples"><h2>Usage examples</h2></a>
<a class="header" href="#register-a-node" id="register-a-node"><h3>Register a node</h3></a>
<p>To provide your computation resources to Fluence network, you need to register your computer within smart-contract. The simplest way to do that is through CLI.
The following command will register a node:</p>
<pre><code>./fluence register \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \            
            --account               0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --base64_tendermint_key \
            --secret_key            0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>Parameters are:</p>
<ul>
<li>advertised address <code>85.82.118.4</code>, please note that this address should be available from Internet as it will be used to connect with other workers in a future cluster</li>
<li>Tendermint key (used to identify node) <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>, note base64 format
<ul>
<li>flag <code>--base64_tendermint_key</code> passed so tendermint key is treated as base64-encoded as opposed to hex-encoded</li>
<li>currently, Tendermint key can be found in logs of <code>fluencelabs/node</code> Docker container</li>
<li>note that key should be unique, i.e. you can't register several nodes with the same key</li>
</ul>
</li>
<li>Tendermint p2p node ID <code>5e4eedba85fda7451356a03caffb0716e599679b</code> is needed to securely connect nodes in Tendermint cluster</li>
<li><code>0x9995882876ae612bfd829498ccd73dd962ec950a</code> is a contract address, register transaction will be sent there</li>
<li><code>0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d</code> will be used as Ethereum account for issuing transactions. <em>Use your Ethereum account here</em></li>
<li><code>--secret_key 0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133</code> denotes an Ethereum private key, used for offline transaction signing. <em>Use your Ethereum private key here</em>
<ul>
<li>using <code>--password</code> is possible instead of private key, but private key is preferred</li>
</ul>
</li>
<li><code>--wait_syncing</code> so CLI waits until Ethereum node is fully synced</li>
<li><code>--api_port 25000</code> specifies the main port of the Fluence node, so other nodes and users know where to connect</li>
<li><code>--capacity 10</code> limits number of apps that could be run on the node by 10</li>
</ul>
<a class="header" href="#publish-an-app" id="publish-an-app"><h3>Publish an app</h3></a>
<p>To deploy your app on Fluence network, you must upload it to Swarm and publish hash to smart-contract. The simplest way to achieve that is to use CLI command <code>publish</code>.</p>
<p>The following command will publish app <code>counter.wasm</code>.</p>
<pre><code>./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     4 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64
</code></pre>
<p>Interesting bits:</p>
<ul>
<li><code>--cluster_size 4</code> requires cluster of 4 workers to host this app</li>
<li><code>--pin_to 1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= --base64</code> requires that one of the node in cluster must be <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>
<ul>
<li>note that to be used in <code>pin_to</code> node must be already registered in smart-contract</li>
</ul>
</li>
<li><code>fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm</code> is just an example path and doesn't exist in project
<ul>
<li>however, you can build it by issuing <code>sbt vm-counter/compile</code> in project root</li>
</ul>
</li>
</ul>
<p>NOTE: currently maximum <code>cluster_size</code> is limited by <code>4</code>. This is to limit resource exhaustion. To use a cluster of larger size, you can <a href="tools/../docs/src/roles/miner.html">spin up your own nodes</a>, and ping to them via <code>--pin_to</code> flag.</p>
<p>Please refer to <a href="tools/../backend-sdk/README.html">Fluence Rust SDK</a> and <a href="tools/../docs/src/quickstart/rust.html">Rust guide</a> to get information about developing apps with Fluence.</p>
<a class="header" href="#waiting-for-an-app-to-be-deployed-or-enqueued" id="waiting-for-an-app-to-be-deployed-or-enqueued"><h4>Waiting for an app to be deployed or enqueued</h4></a>
<p>You can pass <code>--wait</code> option to <code>publish</code> command, and CLI will wait until transaction is included in a block, and then provide you with information about app deployment status and app id.
Deployed application:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
[3/3]   Transaction was included. ---&gt; [00:00:00]
App deployed.
   app id: 1
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
</code></pre>
<p>Enqueued:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
[3/3]   Transaction was included. ---&gt; [00:00:00]
App enqueued.
   app id: 2
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
</code></pre>
<a class="header" href="#delete-an-app" id="delete-an-app"><h3>Delete an app</h3></a>
<p>If you want to delete your app from smart contract, you can use <code>delete_app</code> command.</p>
<p>The following will delete app with id <code>0x0000000000000000000000000000000000000000000000000000000000000002</code>. App id could be retrieved either from status (see below) or from smart-contract.</p>
<pre><code>./fluence delete_app \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --app_id           0x0000000000000000000000000000000000000000000000000000000000000002 \
            --secret_key       4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 \
            --deployed
</code></pre>
<p>Note <code>--deployed</code> at the end. It means that app is deployed and cluster hosting it should be deleted as well. Without that flag, app would be removed only if there is no assigned cluster (i.e., app is not yet deployed).</p>
<p>See below on how to know if your app is deployed.</p>
<a class="header" href="#retrieve-fluence-network-state-as-json" id="retrieve-fluence-network-state-as-json"><h3>Retrieve Fluence network state as JSON</h3></a>
<p>To inspect what apps are in queue, what clusters are working out there and what nodes are participating in them, you can use <code>status</code> command as follows:</p>
<pre><code>./fluence status
</code></pre>
<p>The results will be in JSON and should resemble the following</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x64b8f12d14925394ae0119466dff6ff2b021a3e9&quot;,
      &quot;pin_to_nodes&quot;: [],
      &quot;cluster&quot;: null
    },
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000005&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
        &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
        &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
        &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
        &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
      ],
      &quot;cluster&quot;: {
        &quot;genesis_time&quot;: 1547643251,
        &quot;node_ids&quot;: [
          &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
          &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
          &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
          &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
          &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
        ],
        &quot;ports&quot;: [
          25000,
          25002,
          25004,
          25006,
          25008
        ]
      }
    }
  ]
}
</code></pre>
<p>Here you can see two apps, the first one is enqueued (cluster is <code>null</code>) and waiting for enough nodes to host it, and the second one is already hosted on top of 5 nodes. Second app also specifies all 5 nodes in <code>pin_to_nodes</code>, and you can see the same nodes in <code>cluster.node_ids</code>.</p>
<a class="header" href="#filtering-status" id="filtering-status"><h4>Filtering status</h4></a>
<p>If you need to select specific information from status, you can use different filters:</p>
<pre><code class="language-bash">OPTIONS:
    ...
    -a, --app_id &lt;app_id&gt;                   Filter nodes and apps by app id
    -i, --node_ip &lt;ip address&gt;              Filter nodes by IP address
    -o, --owner &lt;eth address&gt;               Filter nodes and apps owned by this Ethereum address
    -K, --tendermint_key &lt;key&gt;              Filter nodes and apps by Tendermint validator key (node id)
    -f, --filter_mode &lt;and|or&gt;              Logical mode of the filter [default: and]
</code></pre>
<p>Filters work in both JSON and interactive modes. Here's an example of how they can be used:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode or
</code></pre>
<p>This will display all nodes with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code>, all nodes with ip <code>43.32.21.10</code> and all apps hosted by these nodes.</p>
<p>Note <code>--filter_mode or</code>, it directs CLI to match all nodes and apps that satisfy any of specified filters. You can also pass <code>--filter_mode and</code>:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode and
</code></pre>
<p>And you will get only node with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code> <strong>and</strong> IP <code>43.32.21.10</code>, if there is one, and all apps hosted by that node.</p>
<a class="header" href="#tips-and-tricks-1" id="tips-and-tricks-1"><h2>Tips and tricks</h2></a>
<a class="header" href="#waiting-for-an-ethereum-node-to-sync" id="waiting-for-an-ethereum-node-to-sync"><h3>Waiting for an Ethereum node to sync</h3></a>
<p>There is a flag <code>--wait_syncing</code> that, when supplied, will make CLI to wait until your Ethereum node is fully synced. It works by querying <code>eth_syncing</code> until it returns <code>false</code>.</p>
<p>This is handy when you don't want to manually check if Ethereum node is synced.</p>
<a class="header" href="#waiting-for-a-transaction-to-be-included-in-a-block" id="waiting-for-a-transaction-to-be-included-in-a-block"><h3>Waiting for a transaction to be included in a block</h3></a>
<p>There is a flag <code>--wait</code> than, when supplied, will make CLI to wait until the sent transaction is included in a block. It also parses Ethereum events (logs) related to issued command, and will print out some useful information on finish.</p>
<p>For example, when you <code>publish</code> your app, it will tell you the <code>appID</code> and if it's been deployed immediatly or enqueued to wait for enough available nodes.</p>
<p>This is easier that manually checking <code>status</code> after every command.</p>
<p>Note, however, that if you're using Ethereum node in a <strong>light mode</strong>, it can take a while until light node realizes transaction was included in a block. It can take up to several minutes (sometimes up to 10-15 minutes), so it requires some patience.</p>
<a class="header" href="#specify-contract-address" id="specify-contract-address"><h3>Specify contract address</h3></a>
<p>There is a flag <code>--contract_address</code> to use all commands to interact with non-default Fluence smart contract. You can deploy <a href="../bootstrap/contracts/Network.sol">Fluence contract</a> on your own and use CLI like this:</p>
<pre><code class="language-bash">./fluence &lt;command&gt;
            ...
            --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a \
            ...
</code></pre>
<a class="header" href="#interactive-status" id="interactive-status"><h3>Interactive status</h3></a>
<p>If reading raw JSON in <code>status</code> isn't the best option for you, you can use interactive status:</p>
<pre><code class="language-bash">./fluence status --interactive
</code></pre>
<p>It's just a status viewer, but it will gain more functionality in the future.</p>
<a class="header" href="#authorization-and-private-keys" id="authorization-and-private-keys"><h3>Authorization and private keys</h3></a>
<p>There are several ways to provide authorization details for your Ethereum account to Fluence CLI: via keystore JSON file, private key or password for your wallet in Ethereum node.</p>
<a class="header" href="#keystore-json-file" id="keystore-json-file"><h4>Keystore JSON file</h4></a>
<p><strong><em>This is the most secure way to provide your credentials, so it's preffered over other options</em></strong></p>
<p>That's how Geth and a few other tools export private keys. The file looks like this:</p>
<pre><code class="language-json">{&quot;address&quot;:&quot;c2d7cf95645d33006175b78989035c7c9061d3f9&quot;,
  &quot;crypto&quot;:{
    &quot;cipher&quot;:&quot;aes-128-ctr&quot;,
    &quot;ciphertext&quot;:&quot;0f6d343b2a34fe571639235fc16250823c6fe3bc30525d98c41dfdf21a97aedb&quot;,
    &quot;cipherparams&quot;:{
      &quot;iv&quot;:&quot;cabce7fb34e4881870a2419b93f6c796&quot;
    },
    &quot;kdf&quot;:&quot;scrypt&quot;,
    &quot;kdfparams&quot;: {
      &quot;dklen&quot;:32,
      &quot;n&quot;:262144,
      &quot;p&quot;:1,
      &quot;r&quot;:8,
      &quot;salt&quot;:&quot;1af9c4a44cf45fe6fb03dcc126fa56cb0f9e81463683dd6493fb4dc76edddd51&quot;
    },
    &quot;mac&quot;:&quot;5cf4012fffd1fbe41b122386122350c3825a709619224961a16e908c2a366aa6&quot;
  },
  &quot;id&quot;:&quot;eddd71dd-7ad6-4cd3-bc1a-11022f7db76c&quot;,
  &quot;version&quot;:3
}
</code></pre>
<p>It's a private key encrypted with user password. You can use it with Fluence CLI like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --keystore           ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
          --passowrd           my_secure_passw0rd
</code></pre>
<p>For example, with <code>delete_app</code></p>
<pre><code class="language-bash">./fluence delete_app \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --app_id           0x0000000000000000000000000000000000000000000000000000000000000002 \
            --keystore         ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
            --password         my_secure_passw0rd \
            --deployed
</code></pre>
<p>Decrypted private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#private-key" id="private-key"><h4>Private key</h4></a>
<p>Other option is to provide unencrypted private key, like in most examples above:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --secret_key         4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 
</code></pre>
<p>Since private key isn't encrypted, no password is required.</p>
<p>Private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#password" id="password"><h4>Password</h4></a>
<p>In case you have a <strong>trusted</strong> Ethereum node with an imported wallet, Fluence CLI can delegate signing a transaction to the Ethereum node. This can be done like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --password           my_secure_passw0rd
</code></pre>
<p><code>personal_sendTransaction</code> will be used to send transaction. It means <strong>your password will be sent over network</strong> to the Ethereum node, and the node will sign and send transaction all by itself. It's preffered to use keystore or private key options instead of providing just a password.</p>
<p>Note, that <strong>your account is not unlocked before, in, or after that operation.</strong></p>
<a class="header" href="#no-authorization" id="no-authorization"><h4>No authorization</h4></a>
<p>It's also possible to avoid providing any credentials:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d
</code></pre>
<p>In that case, transaction is sent to Ethereum node via <code>eth_sendTransaction</code> unsigned, so it's expected that there is no authorization enabled on your node. <strong>This option isn't secure and was meant to be used for testing purposes.</strong></p>
<a class="header" href="#fluence-backend-sdk" id="fluence-backend-sdk"><h2>Fluence backend SDK</h2></a>
<p>Fluence backend SDK contains frequently used functions required to run a backend application in the Fluence network. The library is a work in progress, please, contact Fluence <a href="https://gitter.im/fluencelabs/fluence">Gitter</a> for support. Also you can find more information about this SDK in the <a href="https://fluence.network/fluence/docs/book/backend/">backend guide</a>.</p>
<a class="header" href="#important-client-and-readme-are-under-heavy-development-and-can-be-outdated-ask-a-question-in-gitter-or-file-an-issue" id="important-client-and-readme-are-under-heavy-development-and-can-be-outdated-ask-a-question-in-gitter-or-file-an-issue"><h2>IMPORTANT: Client and README are under heavy development and can be outdated. Ask a question in gitter or file an issue.</h2></a>
<a class="header" href="#fluence-javascript-client" id="fluence-javascript-client"><h2>Fluence Javascript Client</h2></a>
<p><strong>Fluence Javascript Client</strong> allows you to interact with a real-time cluster from a browser or use it like <code>npm</code> module.</p>
<a class="header" href="#motivation-1" id="motivation-1"><h2>Motivation</h2></a>
<p>Browser client simplifies interaction with the real-time cluster for a user. It has zero dependencies and can be added to other code.
Developers can deploy their backend code to Fluence network and built a web3 application based on <strong>Fluence Client</strong> to interact with this backend code.
It is written on TypeScript to reach more clean, understandable and typesafe code with good reusability.</p>
<a class="header" href="#documentation" id="documentation"><h2>Documentation</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/blob/master/docs/guides/frontend.md">Guide</a></p>
<p>TODO</p>
<a class="header" href="#project-status" id="project-status"><h1>Project status</h1></a>
<p>At the current moment, the project is under heavy development, and the architecture described in the <a href="introduction/overview.html">overview</a> is not covered completely by the deployed devnet. Below we have listed features that were already rolled out:</p>
<p><strong>+</strong> Real-time processing layer: real-time clusters with built-in BFT consensus (Tendermint)<br />
<strong>+</strong> Secure metadata storage: real-time clusters state (Ethereum)<br />
<strong>+</strong> Arbitrary code execution: WebAssembly VM (<a href="https://github.com/cretz/asmble">Asmble</a>)<br />
<strong>+</strong> SDK: frontend (JavaScript) and backend (Rust)</p>
<p>Features that have not been released yet:<br />
<strong>–</strong> Batch validation layer: tx history verification, VM state updates<br />
<strong>–</strong> Secure metadata storage: batch validation state, security deposits<br />
<strong>–</strong> Dispute resolution layer: verification game<br />
<strong>–</strong> Data availability layer: Swarm storage for tx history</p>
<p>We tentatively plan to let developers ingest Ethereum transactions, as well as data stored in Swarm/IPFS into Fluence to create decentralized query interfaces. We also plan that other languages such as C++ or JavaScript will be supported for backend development at some point.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-120211353-6', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
