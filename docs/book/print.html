<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fluence book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="overview/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li><a href="overview/motivation.html"><strong aria-hidden="true">1.2.</strong> Motivation</a></li></ol></li><li><a href="whatworks.html"><strong aria-hidden="true">2.</strong> Current state of development</a></li><li><a href="quickstart/plan.html"><strong aria-hidden="true">3.</strong> Quick start</a></li><li><ol class="section"><li><a href="quickstart/rust.html"><strong aria-hidden="true">3.1.</strong> Developing the backend app</a></li><li><a href="quickstart/publish.html"><strong aria-hidden="true">3.2.</strong> Publishing your app</a></li><li><a href="quickstart/web.html"><strong aria-hidden="true">3.3.</strong> Developing the web app</a></li><li><a href="quickstart/wrappingup.html"><strong aria-hidden="true">3.4.</strong> Wrapping up</a></li></ol></li><li><a href="backend/index.html"><strong aria-hidden="true">4.</strong> Backend guide</a></li><li><ol class="section"><li><a href="backend/app_conventions.html"><strong aria-hidden="true">4.1.</strong> Backend app conventions</a></li><li><a href="backend/sdk_overview.html"><strong aria-hidden="true">4.2.</strong> Fluence backend SDK overview</a></li><li><a href="backend/app_debugging.html"><strong aria-hidden="true">4.3.</strong> Backend app debugging</a></li><li><a href="backend/examples.html"><strong aria-hidden="true">4.4.</strong> Examples</a></li><li><a href="backend/best_practices.html"><strong aria-hidden="true">4.5.</strong> Best practices</a></li></ol></li><li><a href="roles/miner.html"><strong aria-hidden="true">5.</strong> Miner guide</a></li><li><a href="tools/tools.html"><strong aria-hidden="true">6.</strong> Tools and SDKs</a></li><li><ol class="section"><li><a href="tools/cli_README.html"><strong aria-hidden="true">6.1.</strong> CLI</a></li><li><a href="tools/rust_README.html"><strong aria-hidden="true">6.2.</strong> Rust SDK</a></li><li><a href="tools/js_README.html"><strong aria-hidden="true">6.3.</strong> JS SDK</a></li></ol></li><li><a href="unsolved.html"><strong aria-hidden="true">7.</strong> Open problems</a></li><li><a href="examples/examples.html"><strong aria-hidden="true">8.</strong> Examples</a></li><li><ol class="section"><li><a href="examples/backend.html"><strong aria-hidden="true">8.1.</strong> Backend</a></li><li><a href="examples/frontend.html"><strong aria-hidden="true">8.2.</strong> Web apps</a></li></ol></li><li><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Fluence book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#what-is-fluence" id="what-is-fluence"><h2>What is Fluence?</h2></a>
<p>Fluence is a decentralized data processing platform that allows to achieve latency of few seconds for request processing and computational redundancy similar to traditional cloud computing.</p>
<p>In order to achieve low latency and high throughput, Fluence trades security. Fluence provides moderate guarantees that results delivered to the client are correct, but warrants that served results will eventually be additionally verified. If during the additional verification it is found that results were produced incorrectly, offending network nodes lose their deposits.</p>
<p>In the next section we will provide a brief Fluence overview.</p>
<a class="header" href="#overview" id="overview"><h1>Overview</h1></a>
<p>The Fluence network consists of nodes performing computations in response to transactions sent by external clients. Algorithms specifying those computations are expressed in the WebAssembly bytecode; consequently, every node willing to participate in the network has to run a WebAssembly virtual machine.</p>
<p>Independent developers are expected to implement a backend package handling client transactions in a high-level language such as C/C++, Rust, or TypeScript, compile it into one or more We- bAssembly modules, and then deploy those modules to the Fluence network. The network then takes care of spinning up the nodes that run the deployed backend package, interacting with clients, and making sure that client transactions are processed correctly.</p>
<a class="header" href="#architecture" id="architecture"><h2>Architecture</h2></a>
<p>Two major layers exist in the Fluence network: the real-time processing layer and the batch valida- tion layer. The former is responsible for direct interaction with clients; the latter, for computation verification. In other words, real-time processing is the speed layer and batch validation is the security layer. The network also relies on Ethereum (as a secure metadata storage and dispute resolution layer) and Swarm (as a data availability layer)</p>
<div style="text-align:center">
<kbd>
<img src="../images/architecture_overview.png" width="666px"/>
</kbd>
<br><br><br>
</div>
<a class="header" href="#components" id="components"><h2>Components</h2></a>
<a class="header" href="#real-time-processing-layer" id="real-time-processing-layer"><h3>Real-time processing layer</h3></a>
<p>The real-time processing layer consists of multiple real-time clus- ters, which are stateful and keep locally the state required to serve client requests. Each cluster is formed by a few real-time worker nodes that are responsible for running particular backend packages and storing related state data. Workers in real-time clusters use Tendermint to reach BFT consensus and an interim metadata storage (built on top of a DHT such as Kademlia) to temporarily store consensus metadata before it is compacted and uploaded to the Ethereum blockchain.</p>
<p>To deploy a backend package to the Fluence network, the developer first has to allocate a cluster to run the package. Once the package is deployed, those functions that are exposed as external can be invoked by client transactions. If the package is no longer needed, the developer is able to terminate the cluster.</p>
<p>Developers possess significant control over real-time clusters: they are able to specify the desired cluster size and how much memory each node in the cluster should allocate to store the state. If one of the workers in the cluster is struggling, the developer who has allocated the cluster can replace this worker with a more performant one.</p>
<p>Real-time clusters are able to promptly respond to client requests, but those responses carry only moderate security guarantees when a significant fraction of network nodes are malicious. Because real-time clusters are formed by just a few worker nodes, they can tolerate only few malicious nodes, which leaves a non-trivial chance that a real-time cluster might be completely dominated by attackers. Therefore, an additional level of verification is required for computations performed by real-time clusters.</p>
<a class="header" href="#batch-validation-layer" id="batch-validation-layer"><h3>Batch validation layer</h3></a>
<p>To keep real-time clusters in check, the batch validation layer separately verifies all performed computations. This layer is composed of independent batch validators, which are stateless and have to download the required data before performing verification. In order to support this, every real-time cluster is required to upload the history of received transactions and performed state transitions to Swarm. Because Tendermint organizes transactions into blocks that each carry the hash of the state obtained after the previous block execution, real-time clusters upload transactions to Swarm in blocks as well.</p>
<p>Later on, batch validators replay fragments of transaction history, which are composed of one or more blocks, and challenge state transitions that they have deemed incorrect through the dispute resolution layer. If one of the state transitions is not correct, it takes only a single honest validator to challenge this and penalize the real-time cluster that performed the transition.</p>
<p>Developers do not have any control over batch validators beyond deciding how much budget is carved out for batch validation – i.e., how many batch validations should happen for the fragment of transaction history once it is uploaded to Swarm. Furthermore, the batch validator that verifies any specific history fragment is chosen randomly out of all batch validators in the network in order to prevent possible cartels.</p>
<p>Batch validators compact the transaction history and reduce Swarm space usage by uploading intermediate state snapshots to Swarm. Once a transaction history fragment has been verified a sufficient number of times, it is dropped, leaving only the corresponding snapshot.</p>
<a class="header" href="#disputes-resolution-layer" id="disputes-resolution-layer"><h3>Disputes resolution layer</h3></a>
<p>We have already mentioned that batch validators are able to dispute state transitions. This ability is not exclusive to batch validators: a real-time worker can submit a dispute if it disagrees with another real-time worker on how the state should be updated. However, such disputes normally arise only between workers that belong to the same cluster – other real-time workers simply do not carry the required state.</p>
<p>No matter which node has submitted the dispute, it is resolved with the aid of an external authority. The Fluence network uses a specially developed Ethereum smart contract named Arbiter as this authority. Because Ethereum is computationally bounded and thus unable to repeat the entire computation to verify state transitions, a verification game mechanism is used to find the first WebAssembly instruction that produced the diverging states. Only this instruction with the relevant portion of the state is then submitted to the Arbiter contract, which then makes its final decision as to which node performed the incorrect state transition.</p>
<p>Every node in the network is required to put down a significant security deposit before performing computations. If it is found that a node has behaved incorrectly, its deposit is slashed. Assuming that potential adversaries are financially restricted, this reduces the number of cases where a client might receive an incorrect response.</p>
<a class="header" href="#data-availability-layer" id="data-availability-layer"><h3>Data availability layer</h3></a>
<p>The Swarm receipts mechanism is used to make sure that the fragments of transaction history uploaded by the real-time clusters do not disappear before the batch validators replay and verify them. The Swarm receipt is a confirmation from the Swarm node that it is responsible for the specific uploaded data. If the Swarm node is not able to return the data when requested, its deposit is slashed, which prevents Swarm from losing potentially incriminating data.</p>
<a class="header" href="#secure-metadata-storage" id="secure-metadata-storage"><h3>Secure metadata storage</h3></a>
<p>Deposits placed by Fluence network nodes, Swarm receipts issued for transaction history fragments, and metadata entries related to the batch validation and real- time cluster compositions are stored in the Ethereum blockchain. For the sake of simplicity in this paper, we will assume that the Arbiter contract holds this data in addition to its dispute resolution responsibilities.</p>
<a class="header" href="#motivation" id="motivation"><h1>Motivation</h1></a>
<p>To understand the reason behind having two noticeably different layers, we need to recall their properties. Real-time workers are stateful, which considerably improves response latencies because they do not have to download the required state data to perform computations.
As an example, assume that we are building a decentralized SQL database that should support an indexed access to data. Complex queries such as the one listed below often require traversal of multiple indices, which are often implemented as B-trees.</p>
<pre><code class="language-sql">SELECT
    DATE(ts) AS date,
    AVG(gas_price * gas_used) AS tx_cost
FROM transactions tx WHERE
    tx.to IN (SELECT address
              FROM contracts
              WHERE name = ’CryptoDolphins’) 
GROUP BY DATE(ts)
</code></pre>
<p><em>Example query to blockchain data.</em></p>
<p>To traverse a B-tree, we need to sequentially fetch its nodes that satisfy the query conditions. It is not possible to retrieve the required B-tree nodes all at once because the next node to fetch can be determined only by matching the parent B-tree node against the query. If an index is stored externally in a decentralized storage such as IPFS or Swarm, this means that multiple network roundtrips must be performed between the machine performing the computations and the data storage, which significantly increases latency.</p>
<p>Other algorithms, especially those requiring irregular access to data, could benefit from storing their data locally as well. However, data locality significantly increases the economic barrier to joining a real-time cluster because a worker willing to participate in the cluster has to download the current state first. Consequently, this motivates workers to remain in the cluster and thus cluster compositions do not change much over time.</p>
<p>This means that malicious real-time workers in the cluster might form a cartel to produce incorrect results. Without batch validation, every node in the real-time cluster knows it will be verified only by its peers, which are known in advance because clusters are tightly connected. Consequently, malicious nodes can, for example, exploit the following strategy: use a special handshake to recognize other malicious nodes in the cluster and start producing incorrect results if they account for at least 2/3 of the total number of nodes (so they can reach BFT consensus without talking to the rest of the cluster); otherwise, work honestly. This strategy is virtually impossible to catch without external verification.</p>
<p>Furthermore, because real-time clusters are supposed to be small enough to be cost-efficient, the probability that malicious nodes will take over a cluster is significant. For example, for a network where 10% of all nodes are malicious, a real-time cluster that consists of 7 workers independently sampled from the network has approximately a 1.8 · \(10^{−4}\) chance to have at least \(\frac{2}{3}\) malicious nodes.</p>
<p>To counteract this, the batch validation layer provides external verification. Nodes performing batch validation are chosen randomly, which means real-time nodes do not know beforehand which validator will be verifying them and thus cannot collude with the validator in advance.</p>
<p>Batch validation also decreases the probability that an intentional mistake made by a real-time cluster will never get noticed. Assume that in the same network where 10% of all nodes are malicious, we spun a real-time cluster of 4 workers and allocated a budget for 3 batch validations.</p>
<p>In this setup, a mistake can go unnoticed only if malicious actors comprise at least \(\frac{2}{3}\) of the realtime workers and all of the batch validators that verified the transaction history. The chance of this happening is \(≈ 3.7 · 10^{−6}\), which is two orders of magnitude less than in the case where the entire budget was spent on the real-time cluster only.</p>
<p>We also expect that in the presence of batch validators, the fraction of malicious nodes in the network will drop significantly below 10%, because every time a malicious action is caught, the node that performed it loses its deposit and thus leaves the network.</p>
<a class="header" href="#current-state-of-development" id="current-state-of-development"><h1>Current state of development</h1></a>
<a class="header" href="#real-time" id="real-time"><h2>Real-time</h2></a>
<p>Fluence Node and Worker works, and are running on the devnet.</p>
<a class="header" href="#real-time-disputes" id="real-time-disputes"><h3>Real-time disputes</h3></a>
<p>TODO</p>
<a class="header" href="#vm" id="vm"><h2>VM</h2></a>
<p>TODO</p>
<a class="header" href="#validators" id="validators"><h2>Validators</h2></a>
<p>TODO</p>
<a class="header" href="#disputes" id="disputes"><h3>Disputes</h3></a>
<p>TODO</p>
<a class="header" href="#todo" id="todo"><h2>TODO</h2></a>
<a class="header" href="#quickstart" id="quickstart"><h1>Quickstart</h1></a>
<p>This document will guide you through three main steps of development with Fluence.</p>
<p>You will develop a traditional two-tiered web application with a backend written in Rust, and a frontend built with JavaScript. Unlike traditional two-tiered architecture, however, your backend will be decentralized and running on top of the Fluence network, not requiring a dedicated server machine.</p>
<p>We will show you how to use Fluence Rust SDK to develop a backend in Rust, and compile it to WebAssembly. Then, to deploy your backend to the Fluence network, you will publish it to the Fluence smart contract. And finally, build a frontend integrated with your decentralized backend.</p>
<p>If you experience any problems with this guide, or a desire to discuss Fluence with the team, feel free to join our [Discord](TODO: link).</p>
<a class="header" href="#developing-the-backend-app" id="developing-the-backend-app"><h1>Developing the backend app</h1></a>
<p>Fluence runs Webassembly programs, so it's possible to build a Fluence backend in any program language that targets Wasm. In this guide, we will use Rust as a language of choice.</p>
<p>First you will build a simple hello-world backend in Rust, adapt it to be used with Fluence, and compile to Webassembly.</p>
<a class="header" href="#setting-up-rust" id="setting-up-rust"><h2>Setting up Rust</h2></a>
<p>Let's get some Rust.</p>
<p>Install rust compiler and it's tools:</p>
<pre><code class="language-bash"># install Rust compiler and other tools to `~/.cargo/bin`
~ $ curl https://sh.rustup.rs -sSf | sh -s -- -y
info: downloading installer
...
Rust is installed now. Great!
To configure your current shell run source $HOME/.cargo/env
</code></pre>
<p>Let's listen to the installer and configure your current shell:</p>
<pre><code class="language-bash">~ $ source $HOME/.cargo/env
&lt;no output&gt;
</code></pre>
<p>Fluence Rust SDK <a href="???">uses custom allocator (TODO: link)</a> for copying bytes to and from virtual machine internal memory, and that requires nightly toolchain. To install nightly toolchain, run:</p>
<pre><code class="language-bash">~ $ rustup toolchain install nightly
info: syncing channel updates ...
...
  nightly-&lt;arch&gt; installed - rustc 1.34.0-nightly (57d7cfc3c 2019-02-11)
</code></pre>
<p>To check nightly toolchain was installed succesfully:</p>
<pre><code class="language-bash">~ $ rustup toolchain list | grep nightly
# output should contain nighly toolchain
...
nightly-&lt;arch&gt;
</code></pre>
<p>Also, to be able to compile Rust to WebAssembly, we need to add wasm32 compilation target. Just run the following:</p>
<pre><code class="language-bash"># install target for WebAssembly
~ $ rustup target add wasm32-unknown-unknown --toolchain nightly
info: downloading component 'rust-std' for 'wasm32-unknown-unknown'
info: installing component 'rust-std' for 'wasm32-unknown-unknown'
</code></pre>
<p>To check that everything is set up correctly, let's compile some Rust code:</p>
<pre><code class="language-bash"># create test.rs with a simple program that returns number 1
~ $ echo &quot;fn main(){1;}&quot; &gt; test.rs

# compile it to wasm using rustc from nightly toolchain
~ $ rustup run nightly rustc --target=wasm32-unknown-unknown test.rs
&lt;no output&gt;

# check test.wasm was created
~ $ ls -lh test.wasm
-rwxr-xr-x  1 user  user   1.4M Feb 11 11:59 test.wasm
</code></pre>
<p>If everything looks similar, then it's time to create a Rust hello-world project!</p>
<a class="header" href="#creating-an-empty-rust-package" id="creating-an-empty-rust-package"><h2>Creating an empty Rust package</h2></a>
<p>First, let's create a new empty Rust package:</p>
<pre><code class="language-bash"># create empty Rust package
~ $ cargo +nightly new hello-world --edition 2018
Created binary (application) `hello-world` package

# go to the package directory
~ $ cd hello-world
~/hello-world $
</code></pre>
<p>More info on creating a new Rust project can be found in <a href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html">Rust docs</a>.</p>
<a class="header" href="#optional-creating-a-hello-world-rust-application" id="optional-creating-a-hello-world-rust-application"><h2>Optional: Creating a Hello World Rust application</h2></a>
<p>If you are familiar with Rust, feel free to <a href="#creating-a-fluence-hello-world-backend">skip</a> that section.</p>
<p>Let's write some code. Our backend should be able to receive a username from program arguments, and print greeting with the username in it.</p>
<p>Take a look at <code>src/main.rs</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat src/main.rs
</code></pre>
<p>You will see the following code. It's there by default:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>It almost does what we need, except for reading a username. So, open <code>src/main.rs</code> in your editor, delete all the code in there, and paste the following:</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}

fn main() {
    let name = env::args().nth(1).unwrap();
    println!(&quot;{}&quot;, greeting(name));
}
</code></pre></pre>
<p>What this code does:</p>
<ol>
<li>Defines a <code>greeting</code> function that takes a name, and returns a greeting message</li>
<li>Defines a <code>main</code> function that reads first program argument, passes it to <code>greeting</code>, and prints the result</li>
</ol>
<p>Let's now compile and run our example:</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly run myName
   Compiling hello-world v0.1.0 (/root/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/hello-world myName`
Hello, world! From user myName
</code></pre>
<hr />
<p><strong>WARNING:</strong> If you see the following error, you should install <code>gcc</code> and try <code>cargo +nightly run</code> again:</p>
<pre><code class="language-bash">Compiling hello-world v0.1.0 (/root/hello-world)
error: linker cc not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error
error: Could not compile hello-world.
</code></pre>
<hr />
<p>Now that we have a working hello world, it's time to adapt it to be used with Fluence.</p>
<a class="header" href="#creating-a-fluence-hello-world-backend" id="creating-a-fluence-hello-world-backend"><h2>Creating a Fluence Hello World backend</h2></a>
<p>For a backend to be compatible with Fluence network, it should <a href="quickstart/backend.html#wasm-program-conventions">follow a few conventions</a>, so Fluence knows how to call your code correctly. To reduce boilerplate and make it easier, we developed a Fluence Rust SDK. Let's see how to use it.</p>
<a class="header" href="#adding-fluence-as-a-dependency" id="adding-fluence-as-a-dependency"><h3>Adding Fluence as a dependency</h3></a>
<p>First you need to add it to <code>Cargo.toml</code> as a dependency. Let's take a look at <code>Cargo.toml</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat Cargo.toml
</code></pre>
<p>It should look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Now, open <code>Cargo.toml</code> in your editor, and add <code>fluence</code> to <code>dependencies</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#implementing-backend-greeting-logic" id="implementing-backend-greeting-logic"><h3>Implementing backend greeting logic</h3></a>
<p>Create &amp; open <code>~/hello-world/src/lib.rs</code> in your editor and paste the following code there:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
#}</code></pre></pre>
<p>This code imports Fluence SDK, and marks <code>greeting</code> function with <code>#[invocation_handler]</code>, so Fluence knows how to call it.</p>
<p>Function marked with <code>#[invocation_handler]</code> is called a <em>gateway function</em>. It is an entrypoint to your application, all transactions sent by users will be passed to that function, and it's result will be available to users. Gateway function can receive and return either <code>String</code> or <code>Vec&lt;u8&gt;</code>.</p>
<a class="header" href="#making-it-a-library" id="making-it-a-library"><h3>Making it a library</h3></a>
<p>For a gateway function to be exported and available for Fluence to call, backend should be compiled to WebAssembly as a library.</p>
<p>To make your backend a library, open <code>Cargo.toml</code> in your editor, and paste the following there:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[lib]
name = &quot;hello_world&quot;
path = &quot;src/lib.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#compiling-to-webassembly" id="compiling-to-webassembly"><h3>Compiling to WebAssembly</h3></a>
<p>Run the following code to build a <code>.wasm</code> file from your Rust code.</p>
<p>NOTE: Downloading and compiling dependencies might take a few minutes.</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly build --lib --target wasm32-unknown-unknown --release
    Updating crates.io index
    ...
    Finished release [optimized] target(s) in 1m 16s
</code></pre>
<p>If everything goes well, you should have a <code>.wasm</code> file deep in <code>target</code>. Let's check it:</p>
<pre><code class="language-bash">~/hello-world $ ls -lh target/wasm32-unknown-unknown/release/hello_world.wasm
-rwxr-xr-x  2 user  user  1.4M Feb 11 11:59 target/wasm32-unknown-unknown/release/hello_world.wasm
</code></pre>
<a class="header" href="#publishing-your-app" id="publishing-your-app"><h1>Publishing your app</h1></a>
<a class="header" href="#connect-to-swarm-and-ethereum-rinkeby" id="connect-to-swarm-and-ethereum-rinkeby"><h2>Connect to Swarm and Ethereum Rinkeby</h2></a>
<p>To publish a backend app to Fluence network, you need to upload it to Swarm, and then send its location in Swarm to a Fluence smart contract on Ethereum Rinkeby testnet.</p>
<p>To make sure we're on the same page:</p>
<ul>
<li>Swarm is a decentralized file storage.</li>
<li>Ethereum Rinkeby testnet is one of the many Ethereum networks, but there's no real money in there, so it's safe and can be used for trying out something new.</li>
<li>Fluence smart contract is what rules the Fluence network and allows users to use it.</li>
</ul>
<p>To upload your code to Swarm, you need to have access to one of its nodes. The same with Ethereum, you will need a connection to any Ethereum node on Rinkeby testnet.</p>
<p><strong>We will use existing Ethereum &amp; Swarm nodes, but if you wish, you can <a href="quickstart/../roles/miner.html">use your own nodes</a> or any other.</strong></p>
<a class="header" href="#registering-an-ethereum-rinkeby-account" id="registering-an-ethereum-rinkeby-account"><h2>Registering an Ethereum Rinkeby account</h2></a>
<a class="header" href="#via-myetherwalletcom" id="via-myetherwalletcom"><h3>Via myetherwallet.com</h3></a>
<p>Go to <a href="https://vintage.myetherwallet.com/">MyEtherWallet.com</a>, then select Rinkeby in the upper right, enter any password, and download the Keystore file.</p>
<a class="header" href="#top-up-account-with-funds" id="top-up-account-with-funds"><h3>Top up account with funds</h3></a>
<p>Follow instructions for <a href="https://faucet.rinkeby.io/">Rinkeby faucet</a></p>
<a class="header" href="#installing-fluence-cli" id="installing-fluence-cli"><h2>Installing Fluence CLI</h2></a>
<p>You can download Fluence CLI from the <a href="https://github.com/fluencelabs/fluence/releases/">latest release</a></p>
<p>Or in terminal:</p>
<p><strong>Linux</strong></p>
<pre><code class="language-bash">~ $ curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.4/fluence-cli-0.1.4-linux-x64 -o fluence
</code></pre>
<p><strong>macOS</strong></p>
<pre><code class="language-bash">~ $ curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.4/fluence-cli-0.1.4-mac-x64 -o fluence

</code></pre>
<p>And finally don't forget to add permission to execute it:</p>
<pre><code class="language-bash">~ $ chmod +x ./fluence

# check CLI is working
~ $ ./fluence --version
Fluence CLI 0.1.4
</code></pre>
<p>If you see CLI version, proceed to the next step.</p>
<a class="header" href="#publishing-via-fluence-cli" id="publishing-via-fluence-cli"><h2>Publishing via Fluence CLI</h2></a>
<p>As was mentioned before, you will need a connection to Ethereum Rinkeby network, and a connection to Swarm network.</p>
<p>For your convenience, and to make this guide simple, we use addresses of existing Ethereum Rinkeby and Swarm nodes running in a cloud on Fluence nodes. <strong>However, this is a centralized way to connect to Ethereum Rinkeby and Swarm networks, and shouldn't be used in production or in a security-sensitive context.</strong> You may use <strong>any</strong> Rinkeby and Swarm nodes by providing their URIs within <code>--eth_url</code> and <code>--swarm_url</code> options (see below).</p>
<p>Also you will need a Rinkeby account with some money on it (you can <a href="https://faucet.rinkeby.io/">get money from faucet</a>) and it's private key. Private key can be either a hex string or a <a href="quickstart/../cli/README.html#keystore-json-file">JSON keystore file</a>.</p>
<p>Having all that, you're now ready to publish your app. Examples below will specify a cluster size of 4 nodes for your app. Adjust it to your needs.</p>
<p>If you have your private key <strong>in hex</strong>, run the following in your terminal, replacing <code>&lt;&gt;</code> with actual values:</p>
<pre><code class="language-bash">~ $ ./fluence publish \
            --eth_url          http://207.154.232.92:8545 \
            --swarm_url        http://207.154.232.92:8500 \
            --code_path        ~/hello-world/target/wasm32-unknown-unknown/release/hello_world.wasm \
            --gas_price        10 \
            --account          &lt;your ethereum address&gt; \
            --secret_key       &lt;your ethereum private key&gt; \
            --cluster_size     4 \
            --wait_syncing \
            --wait
</code></pre>
<p>If you have a JSON <strong>keystore file</strong>, run the following in your terminal, replacing <code>&lt;&gt;</code> with actual values:</p>
<pre><code class="language-bash">~ $ ./fluence publish \
            --eth_url          http://207.154.232.92:8545 \
            --swarm_url        http://207.154.232.92:8500 \
            --code_path        ~/hello-world/target/wasm32-unknown-unknown/release/hello_world.wasm \
            --gas_price        10 \
            --account          &lt;your ethereum address&gt; \
            --keystore         &lt;path to keystore&gt; \
            --password         &lt;password for keystore&gt; \
            --cluster_size     4 \
            --wait_syncing \
            --wait
</code></pre>
<p>There is more info on using keystore files with Fluence CLI in its <a href="quickstart/../cli/README.html#keystore-json-file">README</a>.</p>
<p>After running the command, you will see an output similar to the following:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0xf5c604478031e9a658551220da3af1f086965b257e7375bbb005e0458c805874
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:03]
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
[3/3]   Transaction was included. ---&gt; [00:02:38]
App deployed.
  app id: 2
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
</code></pre>
<a class="header" href="#check-app-status" id="check-app-status"><h2>Check app status</h2></a>
<p>To see how smart contract sees your app, and what nodes it was deployed onto, you can use <code>status</code> like this:</p>
<pre><code class="language-bash">~ $ ./fluence status \
            --eth_url          http://207.154.232.92:8545 \
            --app_id           &lt;your app id here&gt;
</code></pre>
<p>The output will be in JSON, and look similar to the following:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;&lt;your app id here&gt;&quot;,
      &quot;storage_hash&quot;: &quot;&lt;swarm hash&gt;&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 4,
      &quot;owner&quot;: &quot;&lt;your ethereum address&gt;&quot;,
      &quot;pin_to_nodes&quot;: [],
      &quot;cluster&quot;: {
        &quot;genesis_time&quot;: 1549353504,
        &quot;node_ids&quot;: [
          &quot;0x5ed7aaada4bd800cd4f5b440f36ccece9c9e4542f9808ea6bfa45f84b8198185&quot;,
          &quot;0xb557bb40febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763&quot;,
          &quot;0xac72ccc7886457c3f7da048e184b8b8a43f99c77950e7bb635b6cb3aeb3869fe&quot;,
          &quot;0x9251dd451f4bd9f412173cc21279afc8d885312eb1c21828134ba9095da8306b&quot;,
        ],
        &quot;ports&quot;: [
          25001
        ]
      }
    }
  ],
  &quot;nodes&quot;: [
    {
      &quot;validator_key&quot;: &quot;0x5ed7a87da4bd800cd4f5b440f36ccece9c9e4542f9808ea6bfa45f84b8198185&quot;,
      &quot;tendermint_p2p_id&quot;: &quot;0x6c03a3fe792314f100ac8088a161f70bd7d257b1&quot;,
      &quot;ip_addr&quot;: &quot;43.32.21.10&quot;,
      &quot;next_port&quot;: 25003,
      &quot;last_port&quot;: 25099,
      &quot;owner&quot;: &quot;0x5902720e872fb2b0cd4402c69d6d43c86e973db7&quot;,
      &quot;is_private&quot;: false,
      &quot;app_ids&quot;: [
        1,
        2,
        6
      ]
    },
    &quot;&lt;3 more nodes here&gt;&quot;
  ]
}
</code></pre>
<p>You can also use interactive mode instead of default by supplying <code>--interactive</code> flag:</p>
<pre><code class="language-bash">./fluence status \
            --eth_url          http://207.154.232.92:8545 \
            --app_id           &lt;your app id here&gt; \
            --interactive
</code></pre>
<div style="text-align:center">
<img src="../images/interactive.png" width="776px"/>
<br>
</div>
<p>You can press <code>q</code> to exit it.</p>
<p>Your backend now is successfully deployed! You can proceed to access your code from a web browser.</p>
<a class="header" href="#frontend" id="frontend"><h1>Frontend</h1></a>
<p>For this part, you will need installed <code>npm</code>. Please refer to <a href="https://www.npmjs.com/get-npm">npm docs</a> for installation instructions.</p>
<a class="header" href="#preparing-web-app" id="preparing-web-app"><h2>Preparing web app</h2></a>
<p>Let's clone a simple web app template:</p>
<pre><code class="language-bash">~ $ git clone https://github.com/fluencelabs/frontend-template
~ $ cd frontend-template
~/frontend-template $ 
</code></pre>
<p>There are just three files (except for README, LICENSE and .gitignore):</p>
<ul>
<li><code>package.json</code> that declares needed dependencies</li>
<li><code>webpack.config.js</code> needed for the webpack to work</li>
<li><code>index.js</code> that imports <code>fluence</code> js library and shows how to connect to a cluster</li>
</ul>
<p>Let's take a look at <code>index.js</code>:</p>
<pre><code class="language-javascript">
// address of the Fluence smart contract on Ethereum.
let contractAddress = &quot;0x074a79f29c613f4f7035cec582d0f7e4d3cda2e7&quot;;

// Address of the Ethereum node. If set to `undefined`, MetaMask will be used to send transactions.
let ethUrl = &quot;http://207.154.240.52:8545/&quot;;

// appId of the backend as seen in Fluence smart contract.
let appId = &quot;6&quot;;
...
// create a session between client and backend application
fluence.connect(contractAddress, appId, ethUrl).then((s) =&gt; {
  console.log(&quot;Session created&quot;);
  window.session = s;
  helloBtn.disabled = false;
});
...
// set callback on button click
helloBtn.addEventListener(&quot;click&quot;, send)

// send username as a transaction and display results in grettingLbl
function send() {
  const username = usernameInput.value.trim();
  let result = session.invoke(username);
  getResultString(result).then(function (str) {
    greetingLbl.innerHTML = str;
  });
}
</code></pre>
<p>This code queries the Fluence smart contract for IP addresses of Tendermint nodes hosting the app with specified <code>appId</code>, creates an <code>AppSession</code> from these connections, and saves it to <code>window.session</code>, so it can be used later. All this is done via <code>connect</code> method.</p>
<p>Then, it assigns <code>send()</code> function as a callback for clicking the button, which will call an <code>invoke</code> method provided by <code>AppSession</code>. <code>invoke</code> takes a <code>String</code>, and sends it to the backend as a transaction. Result will be displayed in <code>greeting</code> label.</p>
<a class="header" href="#running-and-using" id="running-and-using"><h2>Running and using</h2></a>
<p>Please make sure you have changed <code>appId</code> to the appId of existing backend. If you haven't published your backend yet, please take a look at <a href="quickstart/publish.html">Publishing guide</a>. You can also use backends published by other people, take a look at</p>
<p>To install all dependencies, compile and run the application, run in the terminal:</p>
<pre><code class="language-bash">~/frontend-template $ npm install
~/frontend-template $ npm run start
&gt; frontend-template@1.0.0 start /private/tmp/frontend-template
&gt; webpack-dev-server

ℹ ｢wds｣: Project is running at http://localhost:8080/
...
</code></pre>
<p>Now you can open http://localhost:8080/ in your browser. You will see an input text box and a disabled button. Button will become enabled once AppSession is created. You can enter your name, and press <code>Say hello!</code> button, and greeting will be displayed next to <code>Result:</code>.</p>
<p>You can also open Developer Console, and you'll see a log about session creation:</p>
<pre><code>...
Connecting web3 to http://207.154.232.92:8545
...
Session created
</code></pre>
<div style="text-align:center">
<kbd>
<img src="../images/helloworld.png" width="529px"/>
</kbd>
<br><br><br>
</div>
<p>You can also use Fluence from within Developer console as follows:</p>
<pre><code class="language-javascript">let result = session.invoke(&quot;myName&quot;);
&lt;undefined&gt;
logResultAsString(result);
&lt;undefined&gt;
Hello, world! From user myName
</code></pre>
<a class="header" href="#wrapping-up" id="wrapping-up"><h1>Wrapping up</h1></a>
<p>Thanks for finishing quick start guide!</p>
<p>A short recap of what you have developed and learned:</p>
<ul>
<li>Set up a Rust and Node.js environments from zero to compiling Webassembly backend and a working web application.</li>
<li>Start with Rust basics, and end up using complex procedural macros and processing user input.</li>
<li>Interact with Ethereum and alter Fluence network state.</li>
<li>Spin up real decentralized backend on top of miners' machines, and integrate JavaScript web app with that backend.</li>
</ul>
<p>Hope this was fun. If you experienced any problems with this guide or Fluence, or just want to chat with the team, feel free to join our <a href="TODO">Discord</a>!</p>
<p>If you want to do more with Fluence, you can help us out by looking at <a href="quickstart/../unsolved.html">open problems</a> or <a href="https://github.com/fluencelabs/fluence/issues">open issues</a>, and give us some feedback.</p>
<p>Also, there are more examples of <a href="">backends</a> and <a href="">web apps</a>, take a look.</p>
<a class="header" href="#backend-guide" id="backend-guide"><h1>Backend guide</h1></a>
<p>The Fluence network is designed to run Webassembly (Wasm) applications (<code>app</code>) in decentralized trustless environments. Generally, it can be considered as several logical parts: a <code>client-side</code> (a frontend part used for sending requests to Wasm program), the <code>VM wrapper</code> (an intermediate layer that receives queries from client side and routes it to a <code>app</code>) and a <code>app</code> written on Wasm:</p>
<p align="center">
  <img src="images/arch_overview.png" alt="Fluence arch overview" width="700px"/>
</p>
<p>Each <code>app</code> should has some features to be able to run on Fluence. They are described in details in <a href="backend/./app_conventions.html">backend application conventions</a>. To simplify <code>app</code> development we introduced a backend SDK (for more information about it please visit to <a href="backend/./sdk_overview.html">sdk overview</a> and <a href="backend/./app_debugging.html">app debugging</a>). If you are stack with some problem while <code>app</code> developing please refer to <a href="backend/./best_practices.html">best practices</a> and <a href="backend/./examples.html">examples</a> sections of this guide.</p>
<a class="header" href="#backend-app-conventions" id="backend-app-conventions"><h1>Backend app conventions</h1></a>
<a class="header" href="#app-lifecycle" id="app-lifecycle"><h2>App lifecycle</h2></a>
<p>The Fluence network backend infrastructure is based on Scala and Rust. Each computation node in the network has a <code>VM wrapper</code> written on Scala that interacts with a backend <code>app</code> written on Wasm and published to the network by developers. To be able to run supplied Wasm code <a href="https://github.com/fluencelabs/asmble">Asmble</a> is used. It compiles supplied Wasm code to a JVM class that then loaded by <code>VM wrapper</code>. All other interactions between <code>app</code> and <code>VM wrapper</code> occurs in <code>VM wrapper</code> process address space without any inter-process communications.</p>
<p>A <code>main</code> module is invoked by <code>VM wrapper</code> according to the following scheme:</p>
<ol>
<li>
<p>A <code>client-side</code> send a request to <code>App</code> as a byte array.</p>
</li>
<li>
<p><code>VM wrapper</code> call <code>allocate</code> function of <code>main</code> Wasm module with a size of the array.</p>
</li>
<li>
<p><code>VM wrapper</code> writes the array to the module memory.</p>
</li>
<li>
<p><code>VM wrapper</code> call <code>invoke</code> function from <code>main</code> module with the address returned from <code>allocate</code> function and the array size.</p>
</li>
<li>
<p><code>VM wrapper</code> synchronously waits of <code>invoke</code> result. After receiving a <code>pointer</code> from it, reads 4 bytes (that represents <code>size</code> of a byte array) and then reads <code>size</code> bytes from <code>pointer + 4</code> offset (<code>result</code>).</p>
</li>
<li>
<p><code>VM wrapper</code> call <code>deallocate</code> function of <code>main</code> Wasm module with the received pointer.</p>
</li>
<li>
<p>Finally, <code>result</code> as a byte array is sent to a <code>client-side</code>.</p>
</li>
</ol>
<a class="header" href="#fluence-app-conventions" id="fluence-app-conventions"><h2>Fluence App conventions</h2></a>
<p>There are several restriction and conventions that each supplied <code>app</code> has to be met:</p>
<ol>
<li>
<p><code>App</code> can consist of several Wasm modules with different names, but only one of them (let's call it <code>main</code> and all other as <code>sidemodules</code> according to <a href="https://github.com/emscripten-core/emscripten/wiki/Linking#overview-of-dynamic-linking">emcscripten</a>) can be called from <code>user-side</code>. This <code>main</code> module MUST don't have the module name section. This requirement is based on the fact that according to the Wasm specification module name is optional, and now there is no a possibility to add it to a generated Wasm binary by default <code>rust</code> compiler.</p>
</li>
<li>
<p>Each <code>main</code> module MUST have three export (in terms of the Wasm specification) functions with names <code>invoke</code>, <code>allocate</code> and <code>deallocate</code>.</p>
</li>
<li>
<p><code>invoke</code> function is used as the <code>main</code> module handler function. It means that all client-side requests are routed to it. The exactly signature of this function MUST be <code>(func (export &quot;invoke&quot;) (param $buffer i32) (param $size i32) (result i32))</code> in wast representation. It receives two i32 params that represent a pointer to supplied argument and its size. If <code>client-side</code> send an empty byte buffer <code>invoke</code> SHOULD be called with two nulls (it means that according to Fluence protocol implementation honest nodes call <code>invoke</code> with nulls but malicious nodes can do anything). This function has to return a pointer to result that MUST have the next structure in memory: <code>| size (4 bytes; little endian) | result buffer (size bytes) |</code>. This convention is based on the fact that Wasm function can return only one value of i32, i64, f32, f64, i128 but there both pointer and size should be returned.</p>
</li>
<li>
<p><code>allocate</code> function MUST have the next signature <code>(func (export &quot;allocate&quot;) (param $size i32) (result i32))</code> in wast representation. It MUST return a pointer as i32 to a module memory region long enough to hold <code>size</code> bytes.</p>
</li>
<li>
<p><code>deallocate</code> function MUST have the next signature <code>(func (export &quot;deallocate&quot;) (param $address i32) (param $size i32) (return))</code>. It is called by <code>VM wrapper</code> with a pointer to a memory region previously allocated through <code>allocate</code> function and its size. This function SHOULD free this memory region.</p>
</li>
</ol>
<a class="header" href="#fluence-backend-sdk-overview" id="fluence-backend-sdk-overview"><h1>Fluence backend SDK overview</h1></a>
<p>Fluence SDK consists of two crates: <code>main</code> and <code>macro</code>. The first one is used for all memory relative operations and logging (please see <a href="backend/./app_debugging.html">app debugging</a> section for more information). The second one contains a procedural macro to simplify the entry function's signature. These crates can be used separately but the more preferred way is using the global <code>fluence</code> crate that reexport all others. In <code>Rust 2018 edition</code> it can be done by simply adding <code>use fluence::sdk::*</code> to the source.</p>
<a class="header" href="#writing-app-without-sdk" id="writing-app-without-sdk"><h2>Writing app without SDK</h2></a>
<p>For a start, lets review how a simple <code>hello-world</code> <code>app</code> is made without Fluence SDK on pure Rust. From <a href="backend/app_conventions.html">fluence backend conventions</a> it follows that each <code>app</code> must have a <code>main</code> module with three export functions. Keeping in mind restrictions to their signatures, a basic structure of <code>main</code> module can look like that:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; usize {
    ...
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    ...
}

#[no_mangle]
pub unsafe fn deallocate(ptr: *mut u8, size: usize) {
    ...
}
</code></pre>
<p>Note that <code>#[no_mangle]</code> and <code>pub unsafe</code> parts of function signature manage function to be exported from a Wasm module (more information can be found in this <a href="https://internals.rust-lang.org/t/precise-semantics-of-no-mangle/4098">discussion</a>).</p>
<p>To implement <code>hello-world</code> example from <a href="TODO">quick start</a> these functions can be implemented like this:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(_ptr: *mut u8, _len: usize) -&gt; usize {
    let result = &quot;Hello, world!&quot;;
    
    let result_len = result.len();
    let total_len = result_len
        .checked_add(RESULT_SIZE_BYTES)
        .ok_or_else(|| MemError::new(&quot;usize overflow occurred&quot;))?;

    // converts array size to bytes in little-endian
    let len_as_bytes: [u8; RESULT_SIZE_BYTES] = mem::transmute((result_len as u32).to_le());

    // allocates a new memory region for the result
    let result_ptr = alloc(NonZeroUsize::new_unchecked(total_len))?;

    // copies length of array to memory
    ptr::copy_nonoverlapping(
        len_as_bytes.as_ptr(),
        result_ptr.as_ptr(),
        RESULT_SIZE_BYTES,
    );

    // copies array to memory
    ptr::copy_nonoverlapping(
        result.as_ptr(),
        result_ptr.as_ptr().add(RESULT_SIZE_BYTES),
        result_len,
    );

    result_ptr as usize
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    let non_zero_size = NonZeroUsize::new(size)
        .unwrap_or_else(|| panic!(&quot;[Error] Allocation of zero bytes is not allowed.&quot;));
        
    let layout: Layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())?;
    Global.alloc(layout)
        .unwrap_or_else(|_| panic!(&quot;[Error] Allocation of {} bytes failed.&quot;, size))
}

#[no_mangle]
pub unsafe fn deallocate(ptr: NonNull&lt;u8&gt;, size: usize) {
    let non_zero_size = NonZeroUsize::new(size)
        .unwrap_or_else(|| panic!(&quot;[Error] Deallocation of zero bytes is not allowed.&quot;));
    let layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())?;
    Global.dealloc(ptr, layout);
}
</code></pre>
<a class="header" href="#fluence-sdk-usage" id="fluence-sdk-usage"><h2>Fluence SDK usage</h2></a>
<p>From the example above it can be seen that <code>allocate</code> and <code>deallocate</code> functions serve only utility purpose and are normally used only by VM wrapper. These functions aren't any that most of developers would want to implement in their <code>app</code>. Fluence backend SDK provides <code>fluence::memory::alloc</code> and <code>fluence::memory::dealloc</code> functions also based on <a href="https://doc.rust-lang.org/beta/std/alloc/trait.GlobalAlloc.html">GlobalAlloc</a>. They exported by default after including the sdk and can be disabled by specifying the <code>no_export_allocator</code> feature of the sdk.</p>
<p>The <code>invoke</code> function can be also simplified by using the Fluence backend SDK that provides <code>fluence::memory::write_result_to_mem</code> and <code>fluence::memory::read_input_from_mem_</code> in this way:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(_ptr: *mut u8, _len: usize) -&gt; usize {
    let test_str = &quot;Hello, world!&quot;;
    fluence::memory::write_result_to_mem(test_str)
        .unwrap_or_else(|_| {
            panic!(&quot;[Error] Putting the result string into a raw memory was failed&quot;)
        })
        .as_ptr() as usize
}
</code></pre>
<a class="header" href="#invocation-handler-to-the-rescue" id="invocation-handler-to-the-rescue"><h3>Invocation handler to the rescue</h3></a>
<p>The example above can be simplified a little bit more using procedural macros <code>invocation_handler</code> as <code>hello-world</code> example mentioned in <a href="TODO">quick start</a> example:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
</code></pre>
<p>Internally this macros creates a new function <code>invoke</code> that converts a raw argument to appropriate format, calls <code>f</code> and then converts its result via <code>memory::write_result_to_mem</code> from <code>fluence_sdk_main</code>. The following listing shows how this macros is expanded:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; std::ptr::NonNull&lt;u8&gt; {
    let arg = memory::read_input_from_mem(ptr, len);
    let arg = String::from_utf8(arg).unwrap();
    let result = greeting(arg);
    memory::write_result_to_mem(result.as_bytes()).expect(&quot;Putting result string to memory has failed&quot;)
}
</code></pre>
<p>To use this macro with a function <code>f</code> some conditions have to be satisfied:</p>
<ol>
<li>
<p><code>f</code> mustn't have more than one input argument.</p>
</li>
<li>
<p><code>f</code> mustn't be <code>unsafe</code>, <code>const</code>, generic, have custom abi linkage or variadic param.</p>
</li>
<li>
<p>The type of <code>f</code> input (if it present) and output parameters have to be one of {String, Vec<u8>} set.</p>
</li>
<li>
<p><code>f</code> mustn't have the name <code>invoke</code>.</p>
</li>
</ol>
<p>For troubleshooting and macros debugging <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> can be used.</p>
<p>The macro also has an <code>init_fn</code> attribute that can be used for specifying initialization function name. This function will be called only in the first <code>invoke</code> function call. It can be used like this:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() {
    ...
}

#[invocation_handler(init_fn = init)]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>This is expanded to</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() { 
    ...
}

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello from Fluence to {}&quot;, name)
}

static mut IS_INITED: bool = false;

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; std::ptr::NonNull&lt;u8&gt; {
    if !IS_INITED { 
        init();
        unsafe { IS_INITED = true; }
    }
    let arg = memory::read_input_from_mem(ptr, len);
    let arg = String::from_utf8(arg).unwrap();
    let result = greeting(arg);
    memory::write_result_to_mem(result.as_bytes()).expect(&quot;Putting result string to memory has failed&quot;)
}
</code></pre>
<p>Example of usage <code>invocation_handler</code> with <code>init_fn</code> attribure can be found <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">here</a>.</p>
<a class="header" href="#rust-edition-2015" id="rust-edition-2015"><h2>Rust edition 2015</h2></a>
<p>To use Fluence SDK with <code>Rust 2015 edition</code> please import it like this:</p>
<pre><code class="language-Rust">#![feature(custom_attribute)]
extern crate fluence;

use fluence::sdk::*;
</code></pre>
<p>Example of <code>hello-world2</code> <code>app</code> on <code>Rust edition 2015</code> can be found <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2015">here</a>.</p>
<a class="header" href="#backend-app-debugging" id="backend-app-debugging"><h1>Backend app debugging</h1></a>
<a class="header" href="#wasm-logger-usage" id="wasm-logger-usage"><h2>Wasm logger usage</h2></a>
<p>There is a few debugging capabilities for Wasm program. The Fluence network provides a possibility to so-called print-debugging. It can be included by specifying <code>wasm_logger</code> feature of the sdk.</p>
<p>The logger is implemented as a logging facade for crate <a href="https://github.com/rust-lang-nursery/log">log</a>. It means that all <code>log</code> crate possibilities can be used as usual. Let's review it by example of <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">hello-world2</a> application with simple logging:</p>
<pre><code class="language-Rust">use fluence::sdk::*;
use log::info;

fn init() {
    logger::WasmLogger::init_with_level(log::Level::Info).is_ok()
}

#[invocation_handler(init_fn = init)]
fn main(name: String) -&gt; String {
    info!(&quot;{} has been successfully greeted&quot;, name);
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>The easiest way to initialize logger is using the <code>init_fn</code> attribute of <code>invocation_handler</code> like in the example above.</p>
<p>Please also note that this <code>logger</code> designed only for Wasm environment and Fluence <code>WasmVm</code>. Don't use it for other targets and virtual machines. But if it needs to create a project with <code>logger</code> either for Wasm target and other architectures, a conditional compilation can be used:</p>
<pre><code class="language-Rust">fn init() {
    if cfg!(target_arch = &quot;wasm32&quot;) {
        logger::WasmLogger::init_with_level(log::Level::Info).unwrap();
    } else {
        simple_logger::init_with_level(log::Level::Info).unwrap();
    }
}
</code></pre>
<p>It is important to note that by default debugging capabilities is disabled in the Fluence network because of verification game process (you can find more information about it in <a href="TODO">our paper</a>).</p>
<a class="header" href="#usage-of-scala-runner" id="usage-of-scala-runner"><h2>Usage of Scala runner</h2></a>
<p>Sometimes it needs not only a debug output but a possibility to run resulted Wasm <code>app</code> with some different inputs. It can be done by using so-called runner written on Scala (because of it uses a <code>WasmVm</code> implementation that also written on Scala).</p>
<p>Let's a dig a little bit into <code>hello-world2</code> <a href="(https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/runner)">runner</a>. It receives a path to a Wasm binary as the first CLI argument, then creates <code>vm</code> object that extends <code>WasmVm</code> trait. During this creation Wasm code is compiled by Asmble to JVM and loaded into VM. This trait has two public methods: <code>invoke</code> that manages requests to <code>app</code> and <code>getVmState</code> that computes a hash of significant inner state. In the following code snippet</p>
<pre><code class="language-Scala">      inputFile &lt;- EitherT(getWasmFilePath(args).attempt)
        .leftMap(e =&gt; InternalVmError(e.getMessage, Some(e)))
        
      vm ← WasmVm[IO](NonEmptyList.one(inputFile), &quot;fluence.vm.debugger&quot;)
      
      initState ← vm.getVmState[IO]

      result1 ← vm.invoke[IO](None, &quot;John&quot;.getBytes())
</code></pre>
<p><code>inputFile</code> points to supplied path to wasm file. Then WasmVm instance is created with path and <code>fluence.vm.debugger</code> config. This config (for <code>hello-world2</code> <code>app</code> it can be found <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/hello-world2/runner/src/main/resources/reference.conf">here</a>) contains some useful settings that control some inner VM creation process a little bit:</p>
<ul>
<li>
<p><code>defaultMaxMemPages</code> - the maximum number of memory pages when a module doesn't specify it, each Wasm page according to the specification contains 65536 bytes (64 by default, 65536*64 = 4MB)</p>
</li>
<li>
<p><code>loggerRegister</code> - if &gt; 0, registers the logger Wasm module as 'logger' with specified number of memory pages, that allows to logs to stdout (0  by default in mainnet and 2 by default for runners)</p>
</li>
<li>
<p><code>allocateFunctionName</code> - the name of function that should be called for allocation memory (<code>allocate</code> by default)</p>
</li>
<li>
<p><code>deallocateFunctionName</code> - the name of function that should be called for deallocation of previously allocated memory by allocateFunction (<code>deallocate</code> by default)</p>
</li>
<li>
<p><code>invokeFunctionName</code> - the name of the main module handler function (<code>invoke</code> by default)</p>
</li>
</ul>
<p>Then the hash of internal state is computed by <code>vm.getVmState</code> and <code>invoke</code> from <code>app</code> is called by <code>vm.invoke</code>.</p>
<a class="header" href="#examples" id="examples"><h1>Examples</h1></a>
<ul>
<li><a href="#hello-world">Hello-world</a></li>
<li><a href="#hello-world2-with-logging">Hello-world2</a></li>
<li><a href="#llamadb">Llamadb</a></li>
<li><a href="#tic-tac-toe">Tic-tac-toe</a>
<ul>
<li><a href="#function-routing-scheme">Function routing scheme</a></li>
<li><a href="#memory-management">Memory management</a></li>
</ul>
</li>
</ul>
<p>In this sections some examples of backend applications are described.</p>
<a class="header" href="#hello-world" id="hello-world"><h2>Hello-world</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world">Hello-world</a> is a simple demo <code>app</code> for the Fluence network that shows a basic usage of the Fluence SDK.</p>
<a class="header" href="#hello-world2-with-logging" id="hello-world2-with-logging"><h2>Hello-world2 with logging</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">Hello-world2</a> is a simple demo app for the Fluence network that shows either a basic usage and the logger feature of the Fluence SDK.</p>
<a class="header" href="#llamadb" id="llamadb"><h2>Llamadb</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/llamadb">Llamadb</a> <code>app</code> is an example of adopting of existing in-memory SQL database to the Fluence network. This <code>app</code> is based on the original <a href="https://github.com/fluencelabs/llamadb">llamadb</a> database. Since it is in-memory database and doesn't use multithreading, disk storage or other OS features it can be easily ported to the Fluence. All that need to do it is a simple <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/llamadb/src/lib.rs">wrapper</a> that receives requests from <code>client-side</code>, manages it to the original <code>llamadb</code> and returns results back.</p>
<a class="header" href="#tic-tac-toe" id="tic-tac-toe"><h2>Tic-tac-toe</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/tic-tac-toe">tic-tac-toe</a> <code>app</code> is an example of proper memory management and function routing scheme through json. This <code>app</code> provides us with a bunch of public methods:</p>
<ul>
<li>
<p><code>create_payer</code> - creates a new player with a given player name</p>
</li>
<li>
<p><code>create_game</code> - creates a new game for a provided player</p>
</li>
<li>
<p><code>move</code> - makes user and <code>app</code> moves sequentially, returns <code>app</code> move coordinates</p>
</li>
<li>
<p><code>get_game_state</code> - returns state of game for given user (includes board state and user tile)</p>
</li>
<li>
<p><code>get_statistics</code> - retuns overall game statistics includes how registred players count, created game and overall moves count</p>
</li>
</ul>
<a class="header" href="#function-routing-scheme" id="function-routing-scheme"><h3>Function routing scheme</h3></a>
<p>Since there are some public api functions that receives different parameters it needs a way to choose one of them with appropriate parameters. There are several input data format that could be used to reach our goal, but we chose JSON as a one of the most popular that uses text to transmit data objects consisting of key-value pairs.</p>
<p>On the other side one of the most popular json parser for Rust is a <a href="https://github.com/serde-rs/serde">serde</a> library. Serde provides <code>serde_json::from_str</code> method that parses string to a set of <code>serde_json::Value</code> enums and <code>serde_json::from_value</code> method that can translate <code>Value</code> to a concrete struct. It is very useful to parsing json that have the same part.</p>
<p>Let's review it usage on a example of <code>do_request</code> function realization:</p>
<pre><code class="language-Rust">fn do_request(req: String) -&gt; AppResult&lt;Value&gt; {
    let raw_request: Value = serde_json::from_str(req.as_str())?;
    let request: Request = serde_json::from_value(raw_request.clone())?;

    match request.action.as_str() {
        &quot;move&quot; =&gt; {
            let player_move: PlayerMove = serde_json::from_value(raw_request)?;
            GAME_MANAGER.with(|gm| {
                gm.borrow()
                    .make_move(request.player_name, player_move.coords)
            })
        }
        ...
        &quot;create_game&quot; =&gt; {
            let player_tile: PlayerTile = serde_json::from_value(raw_request)?;
            let player_tile = game::Tile::from_char(player_tile.tile).ok_or_else(|| {
                &quot;incorrect tile type, please choose it from {'X', 'O'} set&quot;.to_owned()
            })?;

            GAME_MANAGER.with(|gm| {
                gm.borrow_mut()
                    .create_game(request.player_name, player_tile)
            })
        }

}
</code></pre>
<p>It can be viewed that at first <code>req</code> is parsed to <code>serde_json::Value</code> (and this parsing is occurred only once), then the result is parsed to a <code>Request</code> struct same for all requests. This struct contains <code>action</code> and <code>player_name</code> fields. After this parsing routing could be done by <code>action</code> field value. Each action can has it own request structure and additional parsing to a concrete structure can be done in the same way (please see <code>move</code> and <code>create_game</code> cases from the above example).</p>
<a class="header" href="#memory-management" id="memory-management"><h3>Memory management</h3></a>
<p>Proper memory management is a corner stone of application that provides capabilities to store some user-supplied data. In tic-tac-toe it is solved by using a fixed-size collection for all internal objects that can be of two types: <code>Player</code> and <code>Game</code>. <code>Player</code> contains a string that represents its name and <code>Game</code> contains board state and a tile chosen by user.</p>
<p>Since <code>create_player</code> allows to create an infinite count of <code>Player</code>, they could exhaust all <code>app</code> memory. <a href="https://github.com/andylokandy/arraydeque">ArrayDeque</a> manages to solve this problem by providing a fixed size queue that can pop up object from the front while exceeding the limit.</p>
<p>Then consider a situation when each user can have play to several games or the size of <code>Game</code> is too big compare to the size of <code>Player</code> to give example that is more close to real applications. In this situation one of the approaches is use a separate queue for <code>Game</code> objects (of cause <code>Game</code> can be saved into a <code>Player</code> even in vector or map but consider a more complex design that give a more control of memory management). To implement it each <code>Player</code> should has a smth like id of a proper <code>Game</code> object. Since all of them are placed in queue that can change it position in some time, the only way is using a smart pointers. It this example there are two queues that own <code>Player</code> and <code>Game</code> objects (it means that they store a strong Rc ptr to them) and <code>Player</code> has a weak ptr to a proper <code>Game</code> object.</p>
<p>Also it would be good to find <code>Player</code> object by name more faster than <code>O(n)</code>. To reach it <code>HashMap</code> can be used. And because of our design <code>HashMap</code> should also contains weak pointers to players. According to all of these the final structure could look like this:</p>
<pre><code class="language-Rust">pub struct GameManager {
    players: ArrayDeque&lt;[Rc&lt;RefCell&lt;Player&gt;&gt;; PLAYERS_MAX_COUNT], Wrapping&gt;,
    games: ArrayDeque&lt;[Rc&lt;RefCell&lt;Game&gt;&gt;; GAMES_MAX_COUNT], Wrapping&gt;,
    players_by_name: HashMap&lt;String, Weak&lt;RefCell&lt;Player&gt;&gt;&gt;,
}
</code></pre>
<a class="header" href="#authentication" id="authentication"><h3>Authentication</h3></a>
<p>TBD</p>
<a class="header" href="#best-practices" id="best-practices"><h1>Best practices</h1></a>
<a class="header" href="#memory-management-in-app" id="memory-management-in-app"><h2>Memory management in app</h2></a>
<p>Please pay attention to module memory usage - each <code>app</code> can have maximum 4Gb of heap. But in many situations <code>app</code> can have public API that explicitly or indirectly consumes module memory (e.g. by saving some user data). So users can make a DoS attack to such <code>app</code>. Usually a good memory management can be reach by using fix-size collections like <a href="https://github.com/andylokandy/arraydeque">ArrayDeque</a>. In future Fluence backend SDK will provide some other collections for that.</p>
<p>One example of careful memory management can be found in <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/tic-tac-toe">tic-tac-toe</a>.</p>
<a class="header" href="#shrinking-app-code-size" id="shrinking-app-code-size"><h2>Shrinking app code size</h2></a>
<p>There are some techniques that can reduce size of generated <code>app</code>. Most of them can be found in this nice <a href="https://rustwasm.github.io/book/reference/code-size.html">chapter</a> of <code>Rust and WebAssembly</code> book. But as for the Fluence network to reduce the size of binary as much is possible <code>no_std</code> crate without SDK can be used. The example of <code>hello-world</code> implemented without the SDK can be found in <a href="backend/sdk_overview.html">Fluence SDK overview</a>.</p>
<a class="header" href="#others" id="others"><h2>Others</h2></a>
<ul>
<li>
<p>don't use panic! and methods that lead to it (expect, unwrap) in your code</p>
</li>
<li>
<p>avoid using unsafe operations except these that already in Fluence SDK</p>
</li>
</ul>
<ul>
<li><a href="#fluence-miner-guide">Fluence miner guide</a>
<ul>
<li><a href="#how-mining-works">How mining works</a></li>
<li><a href="#how-to-become-a-fluence-miner">How to become a Fluence miner</a>
<ul>
<li><a href="#deploy-fluence-node-to-a-cloud">Deploy Fluence node to a cloud</a></li>
<li><a href="#deploy-fluence-node-locally">Deploy Fluence node locally</a></li>
</ul>
</li>
<li><a href="#how-to-check-if-node-is-registered">How to check if node is registered</a></li>
<li><a href="#private-nodes-and-application-pinning">Private nodes and application pinning</a>
<ul>
<li><a href="#private-nodes">Private nodes</a></li>
<li><a href="#application-pinning">Application pinning</a>
<ul>
<li><a href="#mixing-pinning-and-matching">Mixing pinning and matching</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#how-to-remove-a-node-from-the-fluence-smart-contract">How to remove a node from the Fluence smart contract</a></li>
<li><a href="#tips-and-tricks">Tips and tricks</a></li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-miner-guide" id="fluence-miner-guide"><h1>Fluence miner guide</h1></a>
<p>Being a miner in Fluence network means that you will provide you computation power to host decentralized backends. In order to do that, you will need just a few things:</p>
<ol>
<li>A computer to run a Fluence node and workers on it</li>
<li>Installed and running Docker and <code>docker-compose</code></li>
<li>Installed python2 pip</li>
<li>An Ethereum light-client or full node connected to Rinkeby testnet</li>
<li>A Rinkeby Ethereum wallet topped up with some ETH to submit transactions</li>
</ol>
<a class="header" href="#how-mining-works" id="how-mining-works"><h2>How mining works</h2></a>
<p>The process is as follows:
You run a Docker image with Fluence node on your computer, then you register that node within Fluence smart contract by using Fluence CLI. On registration, you specify max number of backends you wish to host, so your node doesn't run out of resources.</p>
<p>After you registered your node within smart contract, it starts waiting to be included in an application cluster. That will happen when someone publishes an app and the Fluence smart contract will match that app to your node, and then send an Ethereum event that your node is listening to.</p>
<p>When node receives an event stating it's a part of an application cluster now, it will download application code from Swarm, and then run a Docker image with Fluence worker hosting that code.</p>
<a class="header" href="#how-to-become-a-fluence-miner" id="how-to-become-a-fluence-miner"><h2>How to become a Fluence miner</h2></a>
<p>The first step is to deploy a Fluence node. Deploy is automated, you can get scripts by cloning <a href="https://github.com/fluencelabs/fluence">Fluence repo</a>:</p>
<pre><code>git clone https://github.com/fluencelabs/fluence
</code></pre>
<a class="header" href="#deploy-fluence-node-to-a-cloud" id="deploy-fluence-node-to-a-cloud"><h3>Deploy Fluence node to a cloud</h3></a>
<p>It's an automated task, you will only need to specify your cloud instance IP addresses and your Ethereum wallet, and then run a (Fabric)[https://github.com/fabric/fabric] script.</p>
<p>First, let's install Fabric:</p>
<pre><code class="language-bash"># make use you're using python2
$ pip --version
pip 18.0 from &lt;...&gt; (python 2.7)
$ pip install Fabric==1.14.1
</code></pre>
<p>It should install fabric 1.14.1. <strong>Be careful not to install Fabric 2 as it's not current supported.</strong></p>
<p>Next, open <a href="../../tools/deploy/instances.json">fluence/tools/deploy/instances.json</a> in your favorite text editor, and modify config:</p>
<pre><code class="language-json">{
    &quot;&lt;ip1&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account1&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key1&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    },
    &quot;&lt;ip2&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account2&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key2&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    }
}

</code></pre>
<p>You can specify here several nodes, but for the sake of example, let's continue with a single node. After filling info in deploy_config.json, it should look similar to this:</p>
<pre><code class="language-json">{
    &quot;53.42.31.20&quot;: {
        &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
        &quot;key&quot;: &quot;4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7&quot;,
        &quot;api_port&quot;: &quot;25000&quot;,
        &quot;capacity&quot;: 10
    }
}
</code></pre>
<p>You can also change user running setup commands on cloud instance by <code>env.user</code> to desired username.</p>
<pre><code class="language-python"># Set the username
env.user = &quot;root&quot;
</code></pre>
<p>Now, let's deploy Fluence node along with Geth and Swarm containers:</p>
<pre><code class="language-bash">$ fab deploy
</code></pre>
<p>At the end of the successful deployment you should see something like the following:</p>
<pre><code>[53.42.31.20] out: CONTRACT_ADDRESS=0x074a79f29c613f4f7035cec582d0f7e4d3cda2e7
[53.42.31.20] out: NAME=fluence-node-1
[53.42.31.20] out: HOST_IP=53.42.31.20
[53.42.31.20] out: EXTERNAL_HOST_IP=53.42.31.20
[53.42.31.20] out: OWNER_ADDRESS=0x00a329c0648769a73afac7f9381e08fb43dbea72
...
[53.42.31.20] out: Node container is started.
[53.42.31.20] out: CURRENT NODE = 1
[53.42.31.20] out: TENDERMINT_KEY=YAa6x36acTUIemAoejyplm+cUKe5rhTC1ArMPLMfvFY=
[53.42.31.20] out: API_PORT=25000
[53.42.31.20] out: CAPACITY=10
</code></pre>
<p>Here you have some useful information that you can use with Fluence CLI.</p>
<p>At the very end, you should see something like this:</p>
<pre><code>[53.42.31.20] out: [1/2]   Node synced. ---&gt; [00:00:00]
[53.42.31.20] out: [2/2]   Node added. ---&gt; [00:00:00]
[53.42.31.20] out: Node registered. Submitted transaction: 0x51e1dcf1cf20e136ce66d240e9897c329894c1084e55b13a4fab751fbaced981
</code></pre>
<p>That's the result of script registering your node within Fluence smart contract. You can see it in <a href="../../tools/deploy/scripts/compose.sh">compose.sh</a>:</p>
<pre><code class="language-bash">./fluence register \
        --node_ip           $EXTERNAL_HOST_IP \
        --tendermint_key    $TENDERMINT_KEY \
        --contract_address  $CONTRACT_ADDRESS \
        --account           $OWNER_ADDRESS \
        --secret_key        $PRIVATE_KEY \
        --api_port          $API_PORT \
        --capacity          $CAPACITY \
        --wait_syncing \
        --base64_tendermint_key
</code></pre>
<p>All environment variables used in the command are listed in the useful information above, so you can easily use them with Fluence CLI.</p>
<a class="header" href="#deploy-fluence-node-locally" id="deploy-fluence-node-locally"><h3>Deploy Fluence node locally</h3></a>
<p>If you wish to use your local computer to host Fluence node, you can do that by running <a href="../../tools/deploy/scripts/rinkeby-compose.sh">rinkeby-compose.sh</a> like this:</p>
<pre><code># ./rinkeby-compose.sh &lt;external-ip&gt; &lt;owner-address&gt; &lt;private-key&gt; &lt;api-port&gt; &lt;capacity&gt;
./rinkeby-compose.sh 53.42.31.20 0x00a329c0648769a73afac7f9381e08fb43dbea72 4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 25000 10
</code></pre>
<a class="header" href="#how-to-check-if-node-is-registered" id="how-to-check-if-node-is-registered"><h2>How to check if node is registered</h2></a>
<p>You can use <a href="roles/../../cli/README.html">Fluence CLI</a> to query current state of network in Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence status
</code></pre>
<p><strong>Note:</strong> if your Ethereum node is remote, you can specify it's address via <code>--eth_url</code> option, like this:</p>
<pre><code class="language-bash">./fluence status --eth_url https://53.42.31.20:8545
</code></pre>
<p>You should see your Ethereum address under <code>owner</code> in <code>nodes</code> list. Similar to this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0x6006bac77e9a7135087a60287a3ca9966f9c50a7b9ae14c2d40acc3cb31fbc56&quot;,
      &quot;tendermint_key&quot;: &quot;0x4b4432951f27c2e9a29017b3b6dee46a2e08c3a2&quot;,
      &quot;ip_addr&quot;: &quot;53.42.31.20&quot;,
      &quot;api_port&quot;: 25001,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
      &quot;is_private&quot;: false,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>Please refer to Fluence CLI <a href="roles/../../cli/README.html">README</a> for more info on installation and usage.</p>
<a class="header" href="#private-nodes-and-application-pinning" id="private-nodes-and-application-pinning"><h2>Private nodes and application pinning</h2></a>
<a class="header" href="#private-nodes" id="private-nodes"><h3>Private nodes</h3></a>
<p>By default, after you register a node in the Fluence smart contract, any matching code could be deployed on it. So the node is publici by default.</p>
<p>But if you want to host only your app, there is a way to mark node <strong>private</strong>. That could be to be sure about what apps you're hosting, what's their workload or just to be sure <em>your</em> app gets enough resources to be ran.</p>
<p>When a node is marked as <strong>private</strong>, only your apps can be deployed on that node. This is determined by the Ethereum address that sent the transaction for node registration and for application deployment.</p>
<p>The following command will register a private node:</p>
<pre><code class="language-bash">./fluence register \
            --private \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \
            --contract_address      0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account               0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --base64_tendermint_key \
            --secret_key            0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>As suggested by it's name, it's the <code>--private</code> flag what's making the registered node a private one.</p>
<p>Now, only apps <a href="roles/backend.html">published</a> to Fluence smart contract from your Ethereum address can get deployed on your nodes. <strong>But these apps need to specify nodes they should be hosted on</strong>, that's called <strong>application pinning</strong>.</p>
<a class="header" href="#application-pinning" id="application-pinning"><h3>Application pinning</h3></a>
<p>So, since your nodes are <a href="#private-nodes">private</a>, the application publishing process changes a little: you need to specify IDs of the nodes where you want the application to be hosted. With CLI, that's pretty easy. Assuming you have registered 4 private nodes, and their IDs are:</p>
<ul>
<li><code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code></li>
<li><code>QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI=</code></li>
<li><code>+l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY=</code></li>
<li><code>xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE=</code></li>
</ul>
<p>All you have to do is to provide these node ids to <code>--pin_to</code> flag as a space-separated list:</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \
            --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     4 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p><em>Note that you can pin your app to your both <strong>private</strong> and <strong>public</strong> nodes.</em> Marking node as private just prevents random apps to be deployed on that node.</p>
<a class="header" href="#mixing-pinning-and-matching" id="mixing-pinning-and-matching"><h4>Mixing pinning and matching</h4></a>
<p>The command above is a perfect match, it's pinning the app to four nodes, and also specifies a cluster size of four, so every node hosting the app is directly pinned to it.</p>
<p>But what if your app requires more nodes than you wish to register? In that case, you can pin your app to any number of nodes, be it just one or a few, and specify a cluster size that you need. Fluence smart contract will then match your app both against your pinned nodes and available public nodes. The command is almost the same, except the <code>--cluster_size</code> requires eight nodes.</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        /Users/folex/Development/fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     8 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p>So, assuming contract has just four registered nodes and one app, the <code>./fluence status --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a</code> will look like this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,
      &quot;storage_hash&quot;: &quot;0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 8,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
        &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
        &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
        &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;
      ],
      &quot;cluster&quot;: null
    }
  ],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180rfc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>You see app's <code>cluster</code> is <code>null</code>, that means it's not deployed yet, waiting for enough nodes to be available.</p>
<a class="header" href="#how-to-remove-a-node-from-the-fluence-smart-contract" id="how-to-remove-a-node-from-the-fluence-smart-contract"><h2>How to remove a node from the Fluence smart contract</h2></a>
<p>If you shut down your node, it's not available anymore for any reason, or you just want to stop it hosting apps, you can remove the node from the Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence delete_node \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --tendermint_key   1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64_tendermint_key
</code></pre>
<a class="header" href="#tips-and-tricks" id="tips-and-tricks"><h2>Tips and tricks</h2></a>
<p>CLI has some neat features not described in that guide:</p>
<ul>
<li>Wait until your Ethereum is fully synced</li>
<li>Wait until the transaction is included in a block, printing additional info from contract</li>
<li>Look at smart contract <code>status</code> via interactive command-line table viewer</li>
</ul>
<p>All these features are described in <a href="roles/../../cli/README.html#tips-and-tricks">CLI's readme</a>, so take a look!</p>
<a class="header" href="#fluence-tools-and-sdks" id="fluence-tools-and-sdks"><h1>Fluence tools and SDKs</h1></a>
<ul>
<li><a href="tools/cli_README.html">CLI</a> to interact with Fluence smart contract.</li>
</ul>
<ul>
<li><a href="tools/rust_README.html">Rust SDK</a> will help building a backend in Rust. Also, see the <a href="tools/../quickstart/rust.html">backend quick start</a>.</li>
</ul>
<ul>
<li><a href="tools/js_README.html">JS SDK</a> to interact with backends deployed on top of Fluence. See the <a href="tools/../quickstart/web.html">frontent quick start</a> to learn how to use it.</li>
</ul>
<ul>
<li><a href="#fluence-cli">Fluence CLI</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-examples">Usage examples</a>
<ul>
<li><a href="#register-a-node">Register a node</a></li>
<li><a href="#publish-an-app">Publish an app</a>
<ul>
<li><a href="#waiting-for-an-app-to-be-deployed-or-enqueued">Waiting for an app to be deployed or enqueued</a></li>
</ul>
</li>
<li><a href="#delete-an-app">Delete an app</a></li>
<li><a href="#retrieve-fluence-network-state-as-json">Retrieve Fluence network state as JSON</a>
<ul>
<li><a href="#filtering-status">Filtering status</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tips-and-tricks">Tips and tricks</a>
<ul>
<li><a href="#waiting-for-an-ethereum-node-to-sync">Waiting for an Ethereum node to sync</a></li>
<li><a href="#waiting-for-a-transaction-to-be-included-in-a-block">Waiting for a transaction to be included in a block</a></li>
<li><a href="#interactive-status">Interactive status</a></li>
<li><a href="#authorization-and-private-keys">Authorization and private keys</a>
<ul>
<li><a href="#keystore-json-file">Keystore JSON file</a></li>
<li><a href="#private-key">Private key</a></li>
<li><a href="#password">Password</a></li>
<li><a href="#no-authorization">No authorization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-cli" id="fluence-cli"><h2>Fluence CLI</h2></a>
<p>Fluence CLI is an automation tool for tasks of app management (deployment and deletion), computation resource sharing (node registration), and monitoring Fluence network state (status). See usage for more info.</p>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<p>CLI assumes running Ethereum and Swarm on <code>http://localhost:8545/</code> and <code>http://localhost:8500/</code> respectively. Use <code>--eth_url</code> and <code>--swarm_url</code> to specify actual addresses as you need.</p>
<p>Please note, that your Ethereum account should have sufficient funds for issuing transactions to smart-contract. It's only for transaction fees, Fluence itself doesn't currently charge miners or developers. That could change in the future, for example when miners' deposits are implemented.</p>
<p>Also, take a look at <a href="tools/../tools/deploy/README.html">deployment scripts</a>, they will assist you in running Swarm, Ethereum and Fluence nodes.</p>
<a class="header" href="#installation" id="installation"><h2>Installation</h2></a>
<p>Requirements: <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>cargo</code></a> and <a href="https://www.npmjs.com/get-npm"><code>npm</code></a> are needed.</p>
<ul>
<li>clone this repo and <code>cd</code> to <code>cli</code> folder</li>
<li>run <code>cargo build</code></li>
<li>go to <code>target/debug</code></li>
<li>there is an executable file <code>fluence</code> to work with</li>
</ul>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>To look at all possible arguments and options use <code>./fluence --help</code>:</p>
<p>You can use <code>./fluence [SUBCOMMAND] --help</code> to learn how to use commands.</p>
<a class="header" href="#usage-examples" id="usage-examples"><h2>Usage examples</h2></a>
<a class="header" href="#register-a-node" id="register-a-node"><h3>Register a node</h3></a>
<p>To provide your computation resources to Fluence network, you need to register your computer within smart-contract. The simplest way to do that is through CLI.
The following command will register a node:</p>
<pre><code>./fluence register \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \            
            --account               0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --base64_tendermint_key \
            --secret_key            0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>Parameters are:</p>
<ul>
<li>advertised address <code>85.82.118.4</code>, please note that this address should be available from Internet as it will be used to connect with other workers in a future cluster</li>
<li>Tendermint key (used to identify node) <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>, note base64 format
<ul>
<li>flag <code>--base64_tendermint_key</code> passed so tendermint key is treated as base64-encoded as opposed to hex-encoded</li>
<li>currently, Tendermint key can be found in logs of <code>fluencelabs/node</code> Docker container</li>
<li>note that key should be unique, i.e. you can't register several nodes with the same key</li>
</ul>
</li>
<li>Tendermint p2p node ID <code>5e4eedba85fda7451356a03caffb0716e599679b</code> is needed to securely connect nodes in Tendermint cluster</li>
<li><code>0x9995882876ae612bfd829498ccd73dd962ec950a</code> is a contract address, register transaction will be sent there</li>
<li><code>0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d</code> will be used as Ethereum account for issuing transactions. <em>Use your Ethereum account here</em></li>
<li><code>--secret_key 0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133</code> denotes an Ethereum private key, used for offline transaction signing. <em>Use your Ethereum private key here</em>
<ul>
<li>using <code>--password</code> is possible instead of private key, but private key is preferred</li>
</ul>
</li>
<li><code>--wait_syncing</code> so CLI waits until Ethereum node is fully synced</li>
<li><code>--api_port 25000</code> specifies the main port of the Fluence node, so other nodes and users know where to connect</li>
<li><code>--capacity 10</code> limits number of apps that could be run on the node by 10</li>
</ul>
<a class="header" href="#publish-an-app" id="publish-an-app"><h3>Publish an app</h3></a>
<p>To deploy your app on Fluence network, you must upload it to Swarm and publish hash to smart-contract. The simplest way to achieve that is to use CLI command <code>publish</code>.</p>
<p>The following command will publish app <code>counter.wasm</code>.</p>
<pre><code>./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     4 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64
</code></pre>
<p>Interesting bits:</p>
<ul>
<li><code>--cluster_size 4</code> requires cluster of 4 workers to host this app</li>
<li><code>--pin_to 1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= --base64</code> requires that one of the node in cluster must be <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>
<ul>
<li>note that to be used in <code>pin_to</code> node must be already registered in smart-contract</li>
</ul>
</li>
<li><code>fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm</code> is just an example path and doesn't exist in project
<ul>
<li>however, you can build it by issuing <code>sbt vm-counter/compile</code> in project root</li>
</ul>
</li>
</ul>
<p>Please refer to <a href="tools/../backend-sdk/README.html">Fluence Rust SDK</a> to get information about developing apps with Fluence.</p>
<a class="header" href="#waiting-for-an-app-to-be-deployed-or-enqueued" id="waiting-for-an-app-to-be-deployed-or-enqueued"><h4>Waiting for an app to be deployed or enqueued</h4></a>
<p>You can pass <code>--wait</code> option to <code>publish</code> command, and CLI will wait until transaction is included in a block, and then provide you with information about app deployment status and app id.
Deployed application:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
[3/3]   Transaction was included. ---&gt; [00:00:00]
App deployed.
   app id: 1
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
</code></pre>
<p>Enqueued:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
[3/3]   Transaction was included. ---&gt; [00:00:00]
App enqueued.
   app id: 2
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
</code></pre>
<a class="header" href="#delete-an-app" id="delete-an-app"><h3>Delete an app</h3></a>
<p>If you want to delete your app from smart contract, you can use <code>delete_app</code> command.</p>
<p>The following will delete app with id <code>0x0000000000000000000000000000000000000000000000000000000000000002</code>. App id could be retrieved either from status (see below) or from smart-contract.</p>
<pre><code>./fluence delete_app \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --app_id           0x0000000000000000000000000000000000000000000000000000000000000002 \
            --secret_key       4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 \
            --deployed
</code></pre>
<p>Note <code>--deployed</code> at the end. It means that app is deployed and cluster hosting it should be deleted as well. Without that flag, app would be removed only if there is no assigned cluster (i.e., app is not yet deployed).</p>
<p>See below on how to know if your app is deployed.</p>
<a class="header" href="#retrieve-fluence-network-state-as-json" id="retrieve-fluence-network-state-as-json"><h3>Retrieve Fluence network state as JSON</h3></a>
<p>To inspect what apps are in queue, what clusters are working out there and what nodes are participating in them, you can use <code>status</code> command as follows:</p>
<pre><code>./fluence status
</code></pre>
<p>The results will be in JSON and should resemble the following</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x64b8f12d14925394ae0119466dff6ff2b021a3e9&quot;,
      &quot;pin_to_nodes&quot;: [],
      &quot;cluster&quot;: null
    },
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000005&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
        &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
        &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
        &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
        &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
      ],
      &quot;cluster&quot;: {
        &quot;genesis_time&quot;: 1547643251,
        &quot;node_ids&quot;: [
          &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
          &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
          &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
          &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
          &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
        ],
        &quot;ports&quot;: [
          25000,
          25002,
          25004,
          25006,
          25008
        ]
      }
    }
  ]
}
</code></pre>
<p>Here you can see two apps, the first one is enqueued (cluster is <code>null</code>) and waiting for enough nodes to host it, and the second one is already hosted on top of 5 nodes. Second app also specifies all 5 nodes in <code>pin_to_nodes</code>, and you can see the same nodes in <code>cluster.node_ids</code>.</p>
<a class="header" href="#filtering-status" id="filtering-status"><h4>Filtering status</h4></a>
<p>If you need to select specific information from status, you can use different filters:</p>
<pre><code class="language-bash">OPTIONS:
    ...
    -a, --app_id &lt;app_id&gt;                   Filter nodes and apps by app id
    -i, --node_ip &lt;ip address&gt;              Filter nodes by IP address
    -o, --owner &lt;eth address&gt;               Filter nodes and apps owned by this Ethereum address
    -K, --tendermint_key &lt;key&gt;              Filter nodes and apps by Tendermint validator key (node id)
    -f, --filter_mode &lt;and|or&gt;              Logical mode of the filter [default: and]
</code></pre>
<p>Filters work in both JSON and interactive modes. Here's an example of how they can be used:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode or
</code></pre>
<p>This will display all nodes with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code>, all nodes with ip <code>43.32.21.10</code> and all apps hosted by these nodes.</p>
<p>Note <code>--filter_mode or</code>, it directs CLI to match all nodes and apps that satisfy any of specified filters. You can also pass <code>--filter_mode and</code>:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode and
</code></pre>
<p>And you will get only node with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code> <strong>and</strong> IP <code>43.32.21.10</code>, if there is one, and all apps hosted by that node.</p>
<a class="header" href="#tips-and-tricks-1" id="tips-and-tricks-1"><h2>Tips and tricks</h2></a>
<a class="header" href="#waiting-for-an-ethereum-node-to-sync" id="waiting-for-an-ethereum-node-to-sync"><h3>Waiting for an Ethereum node to sync</h3></a>
<p>There is a flag <code>--wait_syncing</code> that, when supplied, will make CLI to wait until your Ethereum node is fully synced. It works by querying <code>eth_syncing</code> until it returns <code>false</code>.</p>
<p>This is handy when you don't want to manually check if Ethereum node is synced.</p>
<a class="header" href="#waiting-for-a-transaction-to-be-included-in-a-block" id="waiting-for-a-transaction-to-be-included-in-a-block"><h3>Waiting for a transaction to be included in a block</h3></a>
<p>There is a flag <code>--wait</code> than, when supplied, will make CLI to wait until the sent transaction is included in a block. It also parses Ethereum events (logs) related to issued command, and will print out some useful information on finish.</p>
<p>For example, when you <code>publish</code> your app, it will tell you the <code>appID</code> and if it's been deployed immediatly or enqueued to wait for enough available nodes.</p>
<p>This is easier that manually checking <code>status</code> after every command.</p>
<p>Note, however, that if you're using Ethereum node in a <strong>light mode</strong>, it can take a while until light node realizes transaction was included in a block. It can take up to several minutes (sometimes up to 10-15 minutes), so it requires some patience.</p>
<a class="header" href="#specify-contract-address" id="specify-contract-address"><h3>Specify contract address</h3></a>
<p>There is a flag <code>--contract_address</code> to use all commands to interact with non-default Fluence smart contract. You can deploy <a href="../bootstrap/contracts/Network.sol">Fluence contract</a> on your own and use CLI like this:</p>
<pre><code class="language-bash">./fluence &lt;command&gt;
            ...
            --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a \
            ...
</code></pre>
<a class="header" href="#interactive-status" id="interactive-status"><h3>Interactive status</h3></a>
<p>If reading raw JSON in <code>status</code> isn't the best option for you, you can use interactive status:</p>
<pre><code class="language-bash">./fluence status --interactive
</code></pre>
<p>It's just a status viewer, but it will gain more functionality in the future.</p>
<a class="header" href="#authorization-and-private-keys" id="authorization-and-private-keys"><h3>Authorization and private keys</h3></a>
<p>There are several ways to provide authorization details for your Ethereum account to Fluence CLI: via keystore JSON file, private key or password for your wallet in Ethereum node.</p>
<a class="header" href="#keystore-json-file" id="keystore-json-file"><h4>Keystore JSON file</h4></a>
<p><strong><em>This is the most secure way to provide your credentials, so it's preffered over other options</em></strong></p>
<p>That's how Geth and a few other tools export private keys. The file looks like this:</p>
<pre><code class="language-json">{&quot;address&quot;:&quot;c2d7cf95645d33006175b78989035c7c9061d3f9&quot;,
  &quot;crypto&quot;:{
    &quot;cipher&quot;:&quot;aes-128-ctr&quot;,
    &quot;ciphertext&quot;:&quot;0f6d343b2a34fe571639235fc16250823c6fe3bc30525d98c41dfdf21a97aedb&quot;,
    &quot;cipherparams&quot;:{
      &quot;iv&quot;:&quot;cabce7fb34e4881870a2419b93f6c796&quot;
    },
    &quot;kdf&quot;:&quot;scrypt&quot;,
    &quot;kdfparams&quot;: {
      &quot;dklen&quot;:32,
      &quot;n&quot;:262144,
      &quot;p&quot;:1,
      &quot;r&quot;:8,
      &quot;salt&quot;:&quot;1af9c4a44cf45fe6fb03dcc126fa56cb0f9e81463683dd6493fb4dc76edddd51&quot;
    },
    &quot;mac&quot;:&quot;5cf4012fffd1fbe41b122386122350c3825a709619224961a16e908c2a366aa6&quot;
  },
  &quot;id&quot;:&quot;eddd71dd-7ad6-4cd3-bc1a-11022f7db76c&quot;,
  &quot;version&quot;:3
}
</code></pre>
<p>It's a private key encrypted with user password. You can use it with Fluence CLI like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --keystore           ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
          --passowrd           my_secure_passw0rd
</code></pre>
<p>For example, with <code>delete_app</code></p>
<pre><code class="language-bash">./fluence delete_app \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --app_id           0x0000000000000000000000000000000000000000000000000000000000000002 \
            --keystore         ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
            --password         my_secure_passw0rd \
            --deployed
</code></pre>
<p>Decrypted private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#private-key" id="private-key"><h4>Private key</h4></a>
<p>Other option is to provide unencrypted private key, like in most examples above:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --secret_key         4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 
</code></pre>
<p>Since private key isn't encrypted, no password is required.</p>
<p>Private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#password" id="password"><h4>Password</h4></a>
<p>In case you have a <strong>trusted</strong> Ethereum node with an imported wallet, Fluence CLI can delegate signing a transaction to the Ethereum node. This can be done like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --password           my_secure_passw0rd
</code></pre>
<p><code>personal_sendTransaction</code> will be used to send transaction. It means <strong>your password will be sent over network</strong> to the Ethereum node, and the node will sign and send transaction all by itself. It's preffered to use keystore or private key options instead of providing just a password.</p>
<p>Note, that <strong>your account is not unlocked before, in, or after that operation.</strong></p>
<a class="header" href="#no-authorization" id="no-authorization"><h4>No authorization</h4></a>
<p>It's also possible to avoid providing any credentials:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d
</code></pre>
<p>In that case, transaction is sent to Ethereum node via <code>eth_sendTransaction</code> unsigned, so it's expected that there is no authorization enabled on your node. <strong>This option isn't secure and was meant to be used for testing purposes.</strong></p>
<a class="header" href="#fluence-sdk" id="fluence-sdk"><h2>Fluence SDK</h2></a>
<p>Fluence SDK library contains frequently used functions required to integrate
Rust code with the Fluence network VM. The library is a work in progress, please,
contact Fluence <a href="https://gitter.im/fluencelabs/fluence">Gitter</a> for support and
example usage. Also you can find an example of using this SDK in out <a href="https://github.com/fluencelabs/fluence/blob/master/docs/guides/backend.md">backend guide</a>.</p>
<a class="header" href="#important-client-and-readme-are-under-heavy-development-and-can-be-outdated-ask-a-question-in-gitter-or-file-an-issue" id="important-client-and-readme-are-under-heavy-development-and-can-be-outdated-ask-a-question-in-gitter-or-file-an-issue"><h2>IMPORTANT: Client and README are under heavy development and can be outdated. Ask a question in gitter or file an issue.</h2></a>
<a class="header" href="#fluence-javascript-client" id="fluence-javascript-client"><h2>Fluence Javascript Client</h2></a>
<p><strong>Fluence Javascript Client</strong> allows you to interact with a real-time cluster from a browser or use it like <code>npm</code> module.</p>
<a class="header" href="#motivation-1" id="motivation-1"><h2>Motivation</h2></a>
<p>Browser client simplifies interaction with the real-time cluster for a user. It has zero dependencies and can be added to other code.
Developers can deploy their backend code to Fluence network and built a web3 application based on <strong>Fluence Client</strong> to interact with this backend code.
It is written on TypeScript to reach more clean, understandable and typesafe code with good reusability.</p>
<a class="header" href="#documentation" id="documentation"><h2>Documentation</h2></a>
<p><a href="https://github.com/fluencelabs/fluence/blob/master/docs/guides/frontend.md">Guide</a></p>
<p>TODO</p>
<a class="header" href="#open-problems" id="open-problems"><h1>Open problems</h1></a>
<a class="header" href="#support-other-languages-for-backend" id="support-other-languages-for-backend"><h2>Support other languages for backend</h2></a>
<a class="header" href="#c" id="c"><h3>C++</h3></a>
<p>TODO</p>
<a class="header" href="#javascript" id="javascript"><h3>JavaScript</h3></a>
<p>There is a <a href="https://github.com/NectarJS/nectarjs">NectarJS</a> that allows to compile JS to Wasm. Looks like it could work with Fluence.</p>
<a class="header" href="#todo-more-problems" id="todo-more-problems"><h3>TODO: more problems</h3></a>
<a class="header" href="#web-app-examples" id="web-app-examples"><h1>Web app examples</h1></a>
<a class="header" href="#guessing-game" id="guessing-game"><h2>Guessing game</h2></a>
<p>TODO: TBD</p>
<a class="header" href="#chess" id="chess"><h2>Chess</h2></a>
<p>TODO</p>
<a class="header" href="#rest" id="rest"><h2>REST</h2></a>
<p>TODO</p>
<a class="header" href="#backend-examples" id="backend-examples"><h1>Backend examples</h1></a>
<a class="header" href="#tic-tac-toe-1" id="tic-tac-toe-1"><h2>Tic-tac-toe</h2></a>
<p>TODO</p>
<a class="header" href="#llamadb-1" id="llamadb-1"><h2>Llamadb</h2></a>
<p>TODO</p>
<a class="header" href="#benchmarks" id="benchmarks"><h1>Benchmarks</h1></a>
<a class="header" href="#vm-benchmark" id="vm-benchmark"><h2>VM benchmark</h2></a>
<p>TODO: add a link to benchmarking post and code</p>
<a class="header" href="#tendermint-benchmark" id="tendermint-benchmark"><h2>Tendermint benchmark</h2></a>
<p>TODO: add a link to tendermint benchmark</p>
<a class="header" href="#tbd-fluence-benchmark" id="tbd-fluence-benchmark"><h2>TBD: Fluence benchmark</h2></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
