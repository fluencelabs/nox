## VM benchmark tests

This microbenchmark consists of a few tests which can be used to measure performance of various WebAssembly virtual machines. It should be noted this benchmark is by definition is not comprehensive and might not reflect performance on real life workloads. 

However, each test was crafted in a way that would prevent the virtual machine from optimizing them using the dead code elimination. Most tests also prevent intermediate results memoization (with `fibonacci_bigint` and `factorization_reikna` being exceptions) and allow to specify an RNG seed to obtain repeatable benchmark results.

Each test exports the `main` function which is called by the benchmark runner. There are also few compile-time parameters in each test that can be adjusted using the corresponding environment variables. The benchmark has been successfully tested on Mac and should run smoothly on Linux as well.

To run tests Rust Cargo package manager should be installed â€“ the easiest way would be to follow these instructions:

```shell
# download and install rustup
curl -sSf https://static.rust-lang.org/rustup.sh | sh

# install the latest nightly toolchain
~/.cargo/bin/rustup toolchain install nightly

# make shure that Rust is up to date
rustup update

# install the Webassembly target for Rust
rustup target add wasm32-unknown-unknown --toolchain nightly
```
Below we also assume that Fluence GitHub repo has been already cloned and we are in the `vm_bench/tests` directory:

```shell
git clone --recursive https://github.com/fluencelabs/fluence
cd fluence/vm/vm_bench/tests
```

Random numbers in tests are generated with [IsaacRng](https://doc.rust-lang.org/1.0.0/rand/isaac/struct.IsaacRng.html). It should also be noted relative results of the QR and SVG decomposition tests can be somewhat different on different hardware because of the floating point non-determinism.

### Compression

This test compresses a sequence of `SEQUENCE_SIZE` bytes and has `ITERATIONS_COUNT` iterations of compressions. On each iteration a new sequence is generated by the seed that was computed based on the previous sequence. As the first seed the `SEED` parameter is used. Two compression algorithms ([deflate](https://docs.rs/deflate) and [snappy](https://docs.rs/snap)) are supported and can be chosen by specifying the `deflate_compression` flag.

To run:

```shell
cd recursive_hash
ITERATIONS_COUNT=1 SEED=1000000 SEQUENCE_SIZE=1024 cargo +nightly build --release --target wasm32-unknown-unknown [--feature "deflate_compression"]
```

### Factorization

This test factorizes provided `FACTORIZED_NUMBER` using [reikna](https://docs.rs/reikna/0.10.0/reikna/) library.

To run:

```shell
cd factorization_reikna
FACTORIZED_NUMBER=2147483647 cargo +nightly build --release --target wasm32-unknown-unknown
```

### Recursive fibonacci computing

This test recursively computes the Fibonacci number with the index `FIB_NUMBER`.

To run:

```shell
cd fibonacci_bigint
FIB_NUMBER=38 cargo +nightly build --release --target wasm32-unknown-unknown
```

### Matrix product

This test computes a product of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations; on each iteration new matrices are generated using the seed that was computed using the previous product result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_product
ITERATIONS_COUNT=1000000 SEED=1 MATRIX_SIZE=10 cargo +nightly build --release --target wasm32-unknown-unknown
```

### Matrix QR decomposition

This test computes a QR decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_qr_decomposition
ITERATIONS_COUNT=1000000 SEED=1 MATRIX_SIZE=10 cargo +nightly build --release --target wasm32-unknown-unknown
```

### Matrix SVD decomposition

This test computes an SVD decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_svd_decomposition
ITERATIONS_COUNT=1000000 SEED=1 MATRIX_SIZE=10 cargo +nightly build --release --target wasm32-unknown-unknown
```

### Recursive hash computing

This test iteratively computes a hash chain `hash(hash( ... hash(x)))` of length `ITERATIONS_COUNT`, where `x` is the initial value specified by `INITIAL_VALUE`.

To run:

```shell
cd recursive_hash
ITERATIONS_COUNT=10000000 INITIAL_VALUE=0 cargo +nightly build --release --target wasm32-unknown-unknown
```
