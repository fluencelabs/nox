## VM benchmark tests

This microbenchmark consists of a few tests which can be used to measure performance of various WebAssembly virtual machines. It should be noted this benchmark is by definition is not comprehensive and might not reflect performance on real life workloads. 

However, each test was crafted in a way that would prevent the virtual machine from optimizing them using the dead code elimination. Most tests also prevent intermediate results memoization (with `fibonacci_bigint` and `factorization_reikna` being exceptions) and allow to specify an RNG seed to obtain repeatable benchmark results.

Each test exports the `main` function which is called by the benchmark runner. There are also few compile-time parameters in each test that can be adjusted using the corresponding environment variables. The benchmark has been successfully tested on Mac and should run smoothly on Linux as well.

To run tests Rust Cargo package manager should be installed â€“ the easiest way would be to follow [Rust instructions](https://doc.rust-lang.org/cargo/getting-started/installation.html). Below we also assume that Fluence GitHub repo has been already cloned and we are in the `vm_bench/tests` directory:

```shell
git clone --recursive https://github.com/fluencelabs/fluence
cd fluence/vm/vm_bench/tests
```

### Compression

This test compresses a sequence of `SEQUENCE_SIZE` bytes randomly generated by [IsaacRng](https://doc.rust-lang.org/1.0.0/rand/isaac/struct.IsaacRng.html) and has `ITERATIONS_COUNT` iterations of compressions. On each iteration a new sequence is generated by the seed that was computed based on the previous sequence. As the first seed the `SEED` parameter is used. Two compression algorithms (deflate and snappy) are supported and can be chosen by specifying the `deflate_compression` flag.

To run:

```shell
cd recursive_hash
ITERATIONS_COUNT=<iterations_count> SEED=<seed> SEQUENCE_SIZE=<sequence_size> cargo +nightly build --release --target wasm32-unknown-unknown [--feature "deflate_compression"]
```

### Factorization

This test factorizes provided `FACTORIZED_NUMBER` using [reikna](https://docs.rs/reikna/0.10.0/reikna/) library.

To run:

```shell
cd factorization_reikna
FACTORIZED_NUMBER=<number_to_factorize> cargo build --release --target wasm32-unknown-unknown
```

### Recursive fibonacci computing

This test recursively computes the Fibonacci number with the index `FIB_NUMBER`.

To run:

```shell
cd fibonacci_bigint
FIB_NUMBER=<fibonacci_number> cargo build --release --target wasm32-unknown-unknown
```

### Matrix product

This test computes a product of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations; on each iteration new matrices are generated using the seed that was computed using the previous product result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_product
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Matrix QR decomposition

This test computes a QR decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_qr_decomposition
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Matrix SVD decomposition

This test computes an SVD decomposition of random generated matrices of size `MATRIX_SIZE`. There are `ITERATIONS_COUNT` iterations of decomposition; on each iteration a new matrix is generated using the seed that was computed using the previous decomposition result. As the first seed the `SEED` parameter is used.

To run:

```shell
cd matrix_svd_decomposition
ITERATIONS_COUNT=<iterations_count> SEED=<seed> MATRIX_SIZE=<matrix_size> cargo build --release --target wasm32-unknown-unknown
```

### Recursive hash computing

This test iteratively computes a hash chain `hash(hash( ... hash(x)))` of length `ITERATIONS_COUNT`, where `x` is the initial value specified by `INITIAL_VALUE`.

To run:

```shell
cd recursive_hash
ITERATIONS_COUNT=<iterations_count> INITIAL_VALUE=<initial_value> cargo +nightly build --release --target wasm32-unknown-unknown
```
