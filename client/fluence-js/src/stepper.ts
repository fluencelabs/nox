/*
 * Copyright 2020 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {toByteArray} from "base64-js";
import * as aqua from "./aqua"
import {return_current_peer_id, return_call_service_result, getStringFromWasm0, free} from "./aqua"

import {service} from "./service";
import PeerId from "peer-id";
import log from "loglevel";
import {wasmBs64} from "@fluencelabs/aquamarine-stepper";
import Instance = WebAssembly.Instance;
import Exports = WebAssembly.Exports;
import ExportValue = WebAssembly.ExportValue;

export type InterpreterInvoke = (init_user_id: string, script: string, prev_data: string, data: string) => string
type ImportObject = {
    "./aquamarine_client_bg.js": {
        __wbg_callserviceimpl_7d3cf77a2722659e: (arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any) => void;
        __wbg_getcurrentpeeridimpl_154ce1848a306ff5: (arg0: any) => void;
        __wbindgen_throw: (arg: any) => void;
    };
    host: LogImport
};

type LogImport = {
    log_utf8_string: (level: any, target: any, offset: any, size: any) => void
}

class HostImportsConfig {
    exports: Exports | undefined;
    newImportObject: () => ImportObject;

    constructor(create: (cfg: HostImportsConfig) => ImportObject) {
        this.exports = undefined;
        this.newImportObject = () => create(this);
    }

    setExports(exports: Exports) {
        this.exports = exports;
    }
}

const interpreter_wasm = toByteArray(wasmBs64)

/// Instantiates WebAssembly runtime with AIR interpreter module
async function interpreterInstance(cfg: HostImportsConfig): Promise<Instance> {
    /// Create host imports that use module exports internally
    let imports = cfg.newImportObject();

    /// Instantiate interpreter
    let interpreter_module = await WebAssembly.compile(interpreter_wasm);
    let instance: Instance = await WebAssembly.instantiate(interpreter_module, imports);

    /// Set exports, so host imports can use them
    cfg.setExports(instance.exports);

    /// Trigger interpreter initialization (i.e., call main function)
    call_export(instance.exports.main);

    return instance;
}

/// If export is a function, call it. Otherwise log a warning.
/// NOTE: any here is unavoidable, see Function interface definition
function call_export(f: ExportValue, ...argArray: any[]): any {
    if (typeof f === "function") {
        return f();
    } else {
        log.warn(`can't call export ${f}: it is not a function, but ${typeof f}`)
    }
}

function log_import(cfg: HostImportsConfig): LogImport {
    return {
        log_utf8_string: (level: any, target: any, offset: any, size: any) => {
            let wasm = cfg.exports;
            try {
                let str = getStringFromWasm0(wasm, offset, size);

                switch (level) {
                    case 1:
                        log.error(str)
                        break;
                    case 2:
                        log.warn(str)
                        break;
                    case 3:
                        log.info(str)
                        break;
                    case 4:
                        log.debug(str)
                        break;
                    case 5:
                        // we don't want a trace in trace logs
                        log.debug(str)
                        break;
                }
            } finally {
            }
        }
    };
}

/// Returns import object that describes host functions called by AIR interpreter
function newImportObject(cfg: HostImportsConfig, peerId: PeerId): ImportObject {
    return {
        // __wbg_callserviceimpl_c0ca292e3c8c0c97 this is a function generated by bindgen. Could be changed.
        // If so, an error with a new name will be occurred after wasm initialization.
        "./aquamarine_client_bg.js": {
            __wbg_callserviceimpl_7d3cf77a2722659e: (arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any) => {
                let wasm = cfg.exports;
                try {
                    let serviceId = getStringFromWasm0(wasm, arg1, arg2)
                    let fnName = getStringFromWasm0(wasm, arg3, arg4)
                    let args = getStringFromWasm0(wasm, arg5, arg6);
                    let serviceResult = service(serviceId, fnName, args);
                    let resultStr = JSON.stringify(serviceResult)
                    return_call_service_result(wasm, resultStr, arg0);
                } finally {
                    free(wasm, arg1, arg2)
                    free(wasm, arg3, arg4)
                    free(wasm, arg5, arg6)
                }
            },
            __wbg_getcurrentpeeridimpl_154ce1848a306ff5: (arg0: any) => {
                let peerIdStr = peerId.toB58String();
                let wasm = cfg.exports;
                return_current_peer_id(wasm, peerIdStr, arg0);
            },
            __wbindgen_throw: (arg: any) => {
                console.log(`wbindgen throw: ${JSON.stringify(arg)}`);
            }
        },
        host: log_import(cfg)
    };
}

function newLogImport(cfg: HostImportsConfig): ImportObject {
    return {
        host: log_import(cfg),
        "./aquamarine_client_bg.js": {
            __wbg_callserviceimpl_7d3cf77a2722659e: _ => {},
            __wbg_getcurrentpeeridimpl_154ce1848a306ff5: _ => {},
            __wbindgen_throw: _ => {}
        },
    };
}

/// Instantiates AIR interpreter, and returns its `invoke` function as closure
/// NOTE: an interpreter is also called a stepper from time to time
export async function instantiateInterpreter(peerId: PeerId): Promise<InterpreterInvoke> {
    let cfg = new HostImportsConfig((cfg) => {
        return newImportObject(cfg, peerId);
    })
    let instance = await interpreterInstance(cfg);

    return (init_user_id: string, script: string, prev_data: string, data: string) => {

        let logLevel = log.getLevel()
        let logLevelStr = "info"
        if (logLevel === 0) {
            logLevelStr = "trace"
        } else if (logLevel === 1) {
            logLevelStr = "debug"
        } else if (logLevel === 2) {
            logLevelStr = "info"
        } else if (logLevel === 3) {
            logLevelStr = "warn"
        } else if (logLevel === 4) {
            logLevelStr = "error"
        } else if (logLevel === 5) {
            logLevelStr = "off"
        }

        return aqua.invoke(instance.exports, init_user_id, script, prev_data, data, logLevelStr)
    }
}

/// Instantiate AIR interpreter with host imports containing only logger, but not call_service
/// peerId isn't actually required for AST parsing, but host imports require it, and I don't see any workaround
export async function parseAstClosure(): Promise<(script: string) => string> {
    let cfg = new HostImportsConfig((cfg) => newLogImport(cfg));
    let instance = await interpreterInstance(cfg);

    return (script: string) => {
        return aqua.ast(instance.exports, script)
    };
}
