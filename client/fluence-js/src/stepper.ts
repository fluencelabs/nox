/*
 * Copyright 2020 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {toByteArray} from "base64-js";
import * as aqua from "./aqua"
import {getInt32Memory0, getStringFromWasm0, passStringToWasm0, WASM_VECTOR_LEN} from "./aqua"

import {service} from "./service";
import PeerId from "peer-id";
import log from "loglevel";
import {wasmBs64} from "@fluencelabs/aquamarine-stepper";
import Instance = WebAssembly.Instance;
import Exports = WebAssembly.Exports;
import ExportValue = WebAssembly.ExportValue;
import Imports = WebAssembly.Imports;

export type InterpreterInvoke = (init_user_id: string, script: string, prev_data: string, data: string) => string
type ImportObject = {
    "./aquamarine_client_bg.js": {
        __wbg_callserviceimpl_7d3cf77a2722659e: (arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any) => void;
        __wbg_getcurrentpeeridimpl_154ce1848a306ff5: (arg0: any) => void
    };
    host: LogImport
};

type LogImport = {
    log_utf8_string: (level: any, target: any, offset: any, size: any) => void
}

const interpreter_wasm = toByteArray(wasmBs64)

/// Instantiates WebAssembly runtime with AIR interpreter module
async function interpreterInstance(hostImports: (wasm: Exports) => Imports): Promise<Instance> {
    // Uninitialized exports reference that must be initialized after WebAssembly is instantiated
    let exports: Exports = undefined;
    /// Create host imports that use module exports internally
    let imports = hostImports(exports);

    /// Instantiate interpreter
    let interpreter_module = await WebAssembly.compile(interpreter_wasm);
    let instance: Instance = await WebAssembly.instantiate(interpreter_module, imports);

    /// Finally initialize exports, so host imports can use them
    exports = instance.exports;

    /// Trigger interpreter initialization (i.e., call main function)
    call_export(exports.main);

    return instance;
}

/// If export is a function, call it. Otherwise log a warning.
/// NOTE: any here is unavoidable, see Function interface definition
function call_export(f: ExportValue, ...argArray: any[]): any {
    if (typeof f === "function") {
        return f();
    } else {
        log.warn(`can't call export ${f}: it is not a function, but ${typeof f}`)
    }
}

function log_import(wasm: Exports): LogImport {
    return {
        log_utf8_string: (level: any, target: any, offset: any, size: any) => {
            try {
                let str = getStringFromWasm0(wasm, offset, size)

                switch (level) {
                    case 1:
                        log.error(str)
                        break;
                    case 2:
                        log.warn(str)
                        break;
                    case 3:
                        log.info(str)
                        break;
                    case 4:
                        log.debug(str)
                        break;
                    case 5:
                        // we don't want a trace in trace logs
                            log.debug(str)
                        break;
                }
            } finally {
            }
        }
    };
}

/// Returns import object that describes host functions called by AIR interpreter
function newImportObject(wasm: Exports, peerId: PeerId): ImportObject {
    return {
        // __wbg_callserviceimpl_c0ca292e3c8c0c97 this is a function generated by bindgen. Could be changed.
        // If so, an error with a new name will be occurred after wasm initialization.
        "./aquamarine_client_bg.js": {
            __wbg_callserviceimpl_7d3cf77a2722659e: (arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any) => {
                try {
                    let serviceId = getStringFromWasm0(wasm, arg1, arg2)
                    let fnName = getStringFromWasm0(wasm, arg3, arg4)
                    let args = getStringFromWasm0(wasm, arg5, arg6);
                    var ret = service(serviceId, fnName, args);
                    let retStr = JSON.stringify(ret)
                    var ptr0 = passStringToWasm0(wasm, retStr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                    var len0 = WASM_VECTOR_LEN;
                    getInt32Memory0(wasm)[arg0 / 4 + 1] = len0;
                    getInt32Memory0(wasm)[arg0 / 4 + 0] = ptr0;
                } finally {
                    call_export(wasm.__wbindgen_free, arg1, arg2);
                    call_export(wasm.__wbindgen_free, arg3, arg4);
                    call_export(wasm.__wbindgen_free, arg5, arg6);
                }
            },
            __wbg_getcurrentpeeridimpl_154ce1848a306ff5: (arg0: any) => {
                var ret = peerId.toB58String();
                var ptr0 = passStringToWasm0(wasm, ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
                var len0 = WASM_VECTOR_LEN;
                getInt32Memory0(wasm)[arg0 / 4 + 1] = len0;
                getInt32Memory0(wasm)[arg0 / 4 + 0] = ptr0;
            }
        },
        host: log_import(wasm)
    };
}

function newLogImport(wasm: Exports): ImportObject {
    return {
        host: log_import(wasm),
        "./aquamarine_client_bg.js": {
            __wbg_callserviceimpl_7d3cf77a2722659e: _ => {},
            __wbg_getcurrentpeeridimpl_154ce1848a306ff5: _ => {}
        },
    };
}

/// Instantiates AIR interpreter, and returns its `invoke` function as closure
/// NOTE: an interpreter is also called a stepper from time to time
export async function instantiateInterpreter(peerId: PeerId): Promise<InterpreterInvoke> {
    let instance = await interpreterInstance(wasm => newImportObject(wasm, peerId));

    return (init_user_id: string, script: string, prev_data: string, data: string) => {
        return aqua.invoke(instance.exports, init_user_id, script, prev_data, data)
    }
}

/// Instantiate AIR interpreter with host imports containing only logger, but not call_service
/// peerId isn't actually required for AST parsing, but host imports require it, and I don't see any workaround
export async function parseAstClosure(): Promise<(script: string) => string> {
    let instance = await interpreterInstance(wasm => newLogImport(wasm));

    return (script: string) => {
        return aqua.ast(instance.exports, script)
    };
}
