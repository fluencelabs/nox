/*
 * Nox Fluence Peer
 *
 * Copyright (C) 2024 Fluence DAO
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation version 3 of the
 * License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

use std::time::Duration;

use serde::{Deserialize, Serialize};
use tokio::sync::oneshot;

use crate::Particle;

#[derive(Debug, Default)]
pub enum SendStatus {
    Ok,
    TimedOut {
        after: Duration,
        error: std::io::Error,
    },
    ProtocolError(String),
    NotConnected,
    #[default]
    ConnectionPoolDied,
}

#[derive(Debug, Default)]
pub enum CompletionChannel {
    #[default]
    Ignore,
    Oneshot(oneshot::Sender<SendStatus>),
}

impl CompletionChannel {
    pub fn outlet(self) -> Option<oneshot::Sender<SendStatus>> {
        match self {
            CompletionChannel::Ignore => None,
            CompletionChannel::Oneshot(outlet) => Some(outlet),
        }
    }
}

#[derive(Debug)]
pub enum HandlerMessage {
    /// Particle being sent to remote peer. Contains a channel to signal write completion.
    /// Send-only, can't be received.
    OutParticle(Particle, CompletionChannel),
    /// Particle being received from a remote peer.
    /// Receive-only, can't be sent.
    InParticle(Particle),
    /// Dummy plug. Generated by the `OneshotHandler` when Inbound or Outbound Upgrade happened.
    Upgrade,
}

impl HandlerMessage {
    pub fn into_protocol_message(self) -> (ProtocolMessage, Option<oneshot::Sender<SendStatus>>) {
        match self {
            HandlerMessage::OutParticle(particle, channel) => {
                (ProtocolMessage::Particle(particle), channel.outlet())
            }
            HandlerMessage::Upgrade => (ProtocolMessage::Upgrade, None),
            HandlerMessage::InParticle(_) => {
                unreachable!("InParticle is never sent, only received")
            }
        }
    }
}

// Required by OneShotHandler in inject_fully_negotiated_outbound. And that's because
// <ProtocolMessage as UpgradeOutbound>::Output is (), and OneshotHandler requires it to be
// convertible to OneshotHandler::TEvent which is a ProtocolMessage
impl From<()> for HandlerMessage {
    fn from(_: ()) -> HandlerMessage {
        HandlerMessage::Upgrade
    }
}
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(tag = "action")]
pub enum ProtocolMessage {
    Particle(Particle),
    // TODO: is it needed?
    Upgrade,
}

impl std::fmt::Display for ProtocolMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProtocolMessage::Particle(particle) => particle.fmt(f),
            ProtocolMessage::Upgrade => write!(f, "Upgrade"),
        }
    }
}

impl From<ProtocolMessage> for HandlerMessage {
    fn from(msg: ProtocolMessage) -> HandlerMessage {
        match msg {
            ProtocolMessage::Particle(p) => HandlerMessage::InParticle(p),
            ProtocolMessage::Upgrade => HandlerMessage::Upgrade,
        }
    }
}
