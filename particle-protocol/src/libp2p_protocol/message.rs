/*
 * Copyright 2020 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use crate::Particle;
use fluence_libp2p::types::OneshotOutlet;
use serde::{Deserialize, Serialize};

#[derive(Debug)]
pub enum CompletionChannel {
    Ignore,
    Channel(OneshotOutlet<bool>),
}

impl CompletionChannel {
    pub fn outlet(self) -> Option<OneshotOutlet<bool>> {
        match self {
            CompletionChannel::Ignore => None,
            CompletionChannel::Channel(outlet) => Some(outlet),
        }
    }
}

impl Default for CompletionChannel {
    fn default() -> Self {
        CompletionChannel::Ignore
    }
}

#[derive(Debug)]
pub enum HandlerMessage {
    /// Particle being sent to remote peer. Contains a channel to signal write completion.
    /// Send-only, can't be received.
    OutParticle(Particle, CompletionChannel),
    /// Particle being received from a remote peer.
    /// Receive-only, can't be sent.
    InParticle(Particle),
    /// Error while receiving a message
    InboundUpgradeError(serde_json::Value),
    /// Dummy plug. Generated by the `OneshotHandler` when Inbound or Outbound Upgrade happened.
    Upgrade,
}

// impl Default for ProtocolMessage {
//     fn default() -> Self {
//         ProtocolMessage::Upgrade
//     }
// }

// Required by OneShotHandler in inject_fully_negotiated_outbound. And that's because
// <ProtocolMessage as UpgradeOutbound>::Output is (), and OneshotHandler requires it to be
// convertible to OneshotHandler::TEvent which is a ProtocolMessage
impl Into<HandlerMessage> for () {
    fn into(self) -> HandlerMessage {
        HandlerMessage::Upgrade
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(tag = "action")]
pub enum ProtocolMessage {
    Particle(Particle),
    /// Error while receiving a message
    InboundUpgradeError(serde_json::Value),
    // TODO: is it needed?
    Upgrade,
}

impl Into<(ProtocolMessage, Option<OneshotOutlet<bool>>)> for HandlerMessage {
    fn into(self) -> (ProtocolMessage, Option<OneshotOutlet<bool>>) {
        match self {
            HandlerMessage::OutParticle(particle, channel) => {
                (ProtocolMessage::Particle(particle), channel.outlet())
            }
            HandlerMessage::InboundUpgradeError(err) => {
                (ProtocolMessage::InboundUpgradeError(err), None)
            }
            HandlerMessage::Upgrade => (ProtocolMessage::Upgrade, None),
            HandlerMessage::InParticle(_) => {
                unreachable!("InParticle is never sent, only received")
            }
        }
    }
}

impl Into<HandlerMessage> for ProtocolMessage {
    fn into(self) -> HandlerMessage {
        match self {
            ProtocolMessage::Particle(p) => HandlerMessage::InParticle(p),
            ProtocolMessage::InboundUpgradeError(err) => HandlerMessage::InboundUpgradeError(err),
            ProtocolMessage::Upgrade => HandlerMessage::Upgrade,
        }
    }
}
